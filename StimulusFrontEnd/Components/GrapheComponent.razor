@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntim
@inject Blazored.SessionStorage.ISessionStorageService sessionStorage
@inject IUpdateService updateService

@if(initFinis)
{
    couleurBloquer = "rgb(140,140,140)";
    couleurNonConsulter = "rgb(228, 231, 245)";
    couleurConsulter = "rgb(199,160,53)";
    couleurCompleter = "rgb(28, 90, 47)";  

    couleurTexteBloquer = "#0000FF";
    couleurTexteNonConsulter = "#0000FF";
    couleurTexteConsulter = "#0000FF";
    couleurTexteCompleter = "#0000FF";

        <div id="divGraphiqueComponent">

        <div id="divGrapheEntete">
            <p class="grapheEnteteElement" style="color:white;">zoom : @(Math.Round(scaleZoom * 100))%</p>
            <button class="grapheEnteteElement" style="font-size:15px" type="button" @onclick="AugmenterZoom">+</button>
            <button class="grapheEnteteElement" style="font-size:15px" type="button" @onclick="ReduireZoom">-</button>
            <button class="grapheEnteteElement" type="button" @onclick="ResetViewbox">réinitialiser</button>
            <button class="grapheEnteteElement" type="button" @onclick="MoveToAide">aide</button>

        </div>
        
        <svg id="svgGraphiqueComponent" style="user-select:none" viewBox=@(0 + " " + 0 + " " + sizeSvgDictionary["width"] + " " + sizeSvgDictionary["height"] + "") @onmousewheel="OnWheelMove" @onwheel="OnWheelMove" @onmousedown="OnMouseDown" @onmousemove="OnMouseMove" @onmouseup="OnMouseUp">
            <svg viewBox=@(viewboxDictionary["x"] + " " + viewboxDictionary["y"] + " " + viewboxDictionary["width"] + " " + viewboxDictionary["height"] + "") >
                <!--
                fonction : affiche le tableau 2d qui contients les noeuds.
                    la premiere boucle calcul la hauteur a laquelle les noeuds vont etre afficher pour chaque ligne(donc leur position en y)
                    la deuxieme boucle calcul le positionemment de chaque noeuds sur leur ligne(donc leur position en x)
                variables : 
                    premiere boucle : 
                        i : compteur de la premiere boucle
                        hauteurEtage : hauteur d'un etage du graphique, varie selo la taille et le nombre d'etage
                        paddingTop : espace au dessus du premiere etage du graphe pour fair plus jolie visuellement et pour eviter que le premier noeud soit decouper de moitier
                        positionY : correspond a la position verticale a laquelle les noeuds seront afficher(leur coordonnée y)
                        widthRepartition : corrrespond a la largeur sur laquel les noeuds seront repartie(permet de calculer la position de depart par rapport a la largeur de l'element svg)
                        paddingLeft : espace a gauche des noeuds d'un etage pour centrer les noeuds sur widthRepartition
                        marginLeft : espace a gauche de widthRepartion qui permet de centrer widthRepartition
                        largeurNoeud : espace qu'occupe un noeud sur widthRepartition, permet d'espacer les noeuds


                    deuxieme boucle :
                        j : compteur de la deuxieme boucle
                        positionX : correspond a la position horizontale a laquelle les noeuds seront afficher(leur coordonnée x)
                        iTemporaire : egale au compteur portant un nom similaire(utiliser lors de l'attribution des id dans les fonctions, utiliser les compteurs normaux ne fonctionne pas)
                        jTemporaire : egale au compteur portant un nom similaire(utiliser lors de l'attribution des id dans les fonctions, utiliser les compteurs normaux ne fonctionne pas)
                        couleurAffichage : couleur qu'aura le noeud pour l'affichage. change selon le statut
                        positionYTemporaire : egale a positionY. est utiliser dans les fonction assoscier aux noeuds, utiliser positionY ne fonctionne pas
                        positionXTemporaire : egale a positionX. est utiliser dans les fonction assoscier aux noeuds, utiliser positionX ne fonctionne pas
                        noeudsCoordonneDictionnary : dictionnaire contenant les coordonnes de tout les noeud du graphe. utilise leur id comme clé


                details : 
                    les positions des élements est en pixels car en pourcentage la viewbox agis differemment.
                    les balises <use> sont utiliser pour faire afficher les noeuds parent pardessus les lignes car sinon, les lignes etant dessiner apres, elles étaient afficher pardessus
                    la blaise svg affichant les noeuds est a l'interieur d'une autre balise svg, cela permet d'avoir plusieur couche de svg avec differente viewbox. utiliser pour toujours avoir l'entete au meme endroit
                    la formule mathematique qui calcul widthRepartition pourrais etre ameliorer
            -->
    
                @{
                    
            
                hauteurEtage = (int)Math.Round((double)sizeSvgDictionary["height"] / structureGraphe.GetLength(0));
                paddingTop = (int)Math.Round((double)hauteurEtage / 2);
                positionY = 0;
                widthRepartition = 0;
                paddingLeft = 0;
                marginLeft = 0;
                largeurNoeud = 0;


                positionX = 0;
                couleurAffichageCercle = "";
                couleurAffichageTexte = "";

            
                }

                <circle visibility="@displayHover" cx="@xBordureHover" cy="@yBordureHover" r="@rayonCercleSvg" fill-opacity="0.0" fill="PatWasHere" stroke="#6e9cc4" stroke-width="10px" ></circle>

                @for(int i = 0; i < structureGraphe.GetLength(0); i++)
                {
                    positionY = (int)(hauteurEtage * i + paddingTop);
            
            

                    if(i > 0 && structureGraphe[i].Length >= 1 && structureGraphe[i].Length < 5)
                    {
                        widthRepartition = (int)Math.Round((double)((100 / (6 - structureGraphe[i].Length)) * sizeSvgDictionary["width"] / 100));
                    }
                    else if(structureGraphe[i].Length == 5)
                    {
                        widthRepartition = (int)Math.Round((double)sizeSvgDictionary["width"] / 100 * 62);
                    }
                    else if(structureGraphe[i].Length == 6)
                    {
                        widthRepartition = (int)Math.Round((double)sizeSvgDictionary["width"] / 100 * 73);
                    }
                    else if(structureGraphe[i].Length == 7)
                    {
                        widthRepartition = (int)Math.Round((double)sizeSvgDictionary["width"] / 100 * 84);
                    }
                    else if(structureGraphe[i].Length == 8)
                    {
                        widthRepartition = (int)Math.Round((double)sizeSvgDictionary["width"] / 100 * 95);
                    }
                    else
                    {
                        widthRepartition = sizeSvgDictionary["width"];
                    }
                    

                    marginLeft = (int)Math.Round((double)(sizeSvgDictionary["width"] - widthRepartition) / 2);
                    paddingLeft = (int)Math.Round((double)(widthRepartition / structureGraphe[i].Length) / 2);

                    largeurNoeud = (int)Math.Round((double)widthRepartition / structureGraphe[i].Length);
            

                    for(int j = 0; j < structureGraphe[i].Length; j++)
                    {
                        positionX = marginLeft + (largeurNoeud * j) + paddingLeft;
                        int positionYTemporaire = positionY;
                        int positionXTemporaire = positionX;
                        int iTemporaire = i;
                        int jTemporaire = j;
                        if(structureGraphe[i][j].CodeStatus == 1)
                        {
                            couleurAffichageCercle = couleurBloquer;
                            couleurAffichageTexte = couleurTexteBloquer;
                        }
                        else if(structureGraphe[i][j].CodeStatus == 2)
                        {
                            couleurAffichageCercle = couleurNonConsulter;
                            couleurAffichageTexte = couleurTexteNonConsulter;
                        }
                        else if(structureGraphe[i][j].CodeStatus == 3)
                        {
                            couleurAffichageCercle = couleurConsulter;
                            couleurAffichageTexte = couleurTexteConsulter;
                        }
                        else if(structureGraphe[i][j].CodeStatus == 4)
                        {
                            couleurAffichageCercle = couleurCompleter;
                            couleurAffichageTexte = couleurTexteCompleter;
                        }

                        if(i >= 1)
                        {
                            <line x1="@positionX" y1="@positionY" x2="@(noeudsCoordonneDictionnary[structureGraphe[i][j].LiaisonPrincipal].x)" y2="@(noeudsCoordonneDictionnary[structureGraphe[i][j].LiaisonPrincipal].y)" style="stroke:rgb(100,100,100);stroke-width:2"></line>
                            <use href="@("#group" + structureGraphe[i][j].LiaisonPrincipal)" @onclick="() => OnClick((int)structureGraphe[iTemporaire][jTemporaire].LiaisonPrincipal)" @onmouseover="() => OnMouseOverNoeuds(structureGraphe[iTemporaire][jTemporaire].LiaisonPrincipal)" @onmouseout="() => OnMouseOut()"></use>
                    
                        }
                        <g id=@("group" + structureGraphe[i][j].Id) >
                            <circle id=@("noeud" + structureGraphe[i][j].Id) cx="@positionX" cy="@positionY" r="@rayonCercleSvg" fill="@couleurAffichageCercle" ></circle>
                            <text id=@("text" + structureGraphe[i][j].Id) x=@positionX y=@positionY text-anchor="middle" dominant-baseline="middle" fill="@couleurAffichageTexte" font-size="@(rayonCercleSvg / 2)" textLength="@(Math.Round(rayonCercleSvg * 1.8))" lengthAdjust="spacingAndGlyphs" >@(structureGraphe[i][j].Code)</text>
                            <circle id=@("noeudInv" + structureGraphe[i][j].Id) cx="@positionX" cy="@positionY" r="@rayonCercleSvg" fill-opacity="0.0" fill="PatWasHereTo" @onclick="() => OnClick(structureGraphe[iTemporaire][jTemporaire].Id)" @onmouseover="() => OnMouseOverNoeuds(structureGraphe[iTemporaire][jTemporaire].Id)" @onmouseout="() => OnMouseOut()" ></circle>
                        </g>

                        if(!noeudsCoordonneDictionnary.ContainsKey(structureGraphe[i][j].Id))
                        {
                            noeudsCoordonneDictionnary.Add(structureGraphe[i][j].Id, new Coordonne() { x = positionX, y = positionY });
                        }
                        else
                        {
                            noeudsCoordonneDictionnary[structureGraphe[i][j].Id].x = positionX;
                            noeudsCoordonneDictionnary[structureGraphe[i][j].Id].y = positionY;
                        }
                    }

                }

                


                <rect visibility="@displayHover" x="@positionXRectHover" y="@positionYRectHover" width="@widthRectHover" height="@heightRectHover" fill="grey"></rect>
                <polygon visibility="@displayHover" points="@("" + pointAXPolyHover + "," + pointAYPolyHover + " " + pointBXPolyHover + "," + pointBYPolyHover + " " + pointCXPolyHover + "," + pointCYPolyHover)" fill="grey" ></polygon>
        
                <foreignObject visibility="@displayHover" x="@positionXRectHover" y="@positionYRectHover" width="@(Math.Round(widthRectHover / 2.1))" height="@(heightRectHover / 3)"><p style="color:white; font-size:@(viewboxDictionary["width"] / 100)px;">nom: @nomHover</p></foreignObject>
                <foreignObject visibility="@displayHover" x="@(positionXRectHover + (widthRectHover / 2))" y="@positionYRectHover" width="@(widthRectHover / 2)" height="@(heightRectHover / 3)"><p style="color:white; font-size:@(viewboxDictionary["width"] / 100)px;">pts: @ptsHover</p></foreignObject>
                <foreignObject visibility="@displayHover" x="@positionXRectHover" y="@(positionYRectHover + (heightRectHover / 3))" width="@(Math.Round(widthRectHover / 2.2))" height="@((heightRectHover / 6) * 4)"> <p style="color:white; font-size:@(viewboxDictionary["width"] / 100)px;">desc: @descHover</p> </foreignObject>
                <foreignObject visibility="@displayHover" x="@(positionXRectHover + (widthRectHover / 2))" y="@(positionYRectHover + (heightRectHover / 3))" width="@(widthRectHover / 2)" height="@(heightRectHover / 6)"> <p style="color:white; font-size:@(viewboxDictionary["width"] / 100)px;">prérequis:</p> </foreignObject>            
                @for(int k =0;k < liaisonSecHover.Length;k++)
                {
                    <foreignObject visibility="@displayHover" x="@(positionXRectHover + (widthRectHover / 2))" y="@(positionYRectHover + ((heightRectHover / 6) * (k + 3)))" width="@(widthRectHover / 2)" height="@(heightRectHover / 6)"> <p style="color:white; font-size:@(viewboxDictionary["width"] / 100)px;">@liaisonSecHover[k]</p> </foreignObject>            
                }

                

            </svg>


            <!--
                fonction : affichage de la legende et des statistique
                variables :
                    idTemporaire : egale a hover.id. est utiliser dans les fonction assoscier aux liens, utiliser hover.id ne fonctionne pas
            -->
            <rect width="@widthRectLegend" height="@heightRectLegend" x="5" y="5" fill="#32587a"></rect>
            <foreignObject x="5" y="5" width="@widthRectLegend" height="@heightRectLegend">
                <div>
                    <p style="color:#442f1c; margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">  zoom : Maj▲ + roulette</p>
                    <p style="color:rgb(140,140,140); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">  gris : bloqué</p>
                    <p style="color:rgb(228, 231, 245); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">  blanc: disponible</p>
                    <p style="color:rgb(199,160,53); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">  jaune: consulté</p>
                    <p style="color:rgb(88,150,105); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">  vert : completé</p>
                </div>
            </foreignObject>

            <rect width="@widthRectLegend" height="@heightRectStats" x="@(sizeSvgDictionary["width"] - widthRectLegend - 5)" y="5" fill="#32587a"></rect>
            <foreignObject x="@(sizeSvgDictionary["width"] - widthRectLegend - 5)" y="5" width="@widthRectLegend" height="@heightRectStats">
                <div> 
                    <p style="color:rgb(228, 231, 245); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">@pourcentageCompleter % noeuds completés</p>
                    <p style="color:rgb(228, 231, 245); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">@noeudComplete / @(noeudAffiche.Count() - 1) noeuds completés</p>
                    <p style="color:rgb(228, 231, 245); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">noeuds recommandés :</p>
                    @foreach(GrapheView noeud in topNoeudRecommander)
                    {
                        int idTemporaire = noeud.Id;
                        <p @onclick="() => OnClick(topNoeudRecommander.Where(n => n.Id == idTemporaire).Select(n => n.Id).FirstOrDefault())" style="color:rgb(228, 231, 245); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;" @onmouseover="() => OnMouseOverNoeuds(idTemporaire)" @onmouseout="() => OnMouseOut()"> - <a href="/theorie/@idTemporaire" style="color:rgb(228, 231, 245); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">@noeud.Code</a></p>        
                    }
                    @if(topNoeudRecommander.Count == 0)
                    {
                        <p style="color:rgb(228, 231, 245); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">aucun noeud recommandé</p>
                    }


                </div>
            </foreignObject>
        

        
        
        </svg>
    </div>

}




@code {
    //methode pour le debugage : JSRuntim.InvokeVoidAsync("console.log",x);
    
    public int idGraphe{ get; set;}

    private const double forceZoom = 0.1;

    private double widthViewbox, heightViewbox, mouseX, mouseY, deplacementWidth, deplacementHeight, deplacementX, deplacementY, scaleZoom, translationX, translationY;
    private bool leftClicPress,watchRunning, initFinis,debug,shouldReRender;
    private int rayonCercleSvg,positionXRectHover,positionYRectHover,widthRectHover,heightRectHover,pointAXPolyHover,pointAYPolyHover,pointBXPolyHover,pointBYPolyHover,pointCXPolyHover,pointCYPolyHover,widthRectLegend,heightRectLegend, heightRectStats, noeudComplete, pourcentageCompleter,xBordureHover,yBordureHover;

    private HttpClient httpClient;
    private Client client;
    private IEnumerable<GrapheView> noeudAffiche;
    private IEnumerator<GrapheView> enumerator;
    private IEnumerable<HoverView> infoHover;

    private string displayHover,nomHover,descHover;
    private int? ptsHover;
    private string[] liaisonSecHover;
    private List<GrapheView> topNoeudRecommander;
    private HoverView noeudHover;
    private Coordonne coordonne;

    private Dictionary<string, int> viewboxDictionary = new Dictionary<string, int>();
    private Dictionary<string, int> sizeSvgDictionary = new Dictionary<string, int>(); 
    private Dictionary<string, int> startPointsDictionary = new Dictionary<string, int>(); 
    private Dictionary<string, int> startPointsAbsoluteDictionary = new Dictionary<string, int>(); 
    private Dictionary<string, int> endPointsDictionary = new Dictionary<string, int>();

    private Dictionary<int, Coordonne> noeudsCoordonneDictionnary = new Dictionary<int, Coordonne>();

    private GrapheView[][] structureGraphe = new GrapheView[1][];
    private GrapheView[][] structureGrapheTemporaire = new GrapheView[1][];

    private int[] noeudsParEtages = new int[1];
    private int[] noeudsParEtagesTemporaire = new int[1];



    private BoundingClientRect? element = null;

    //données des boucle d'affichages

    private int hauteurEtage, paddingTop, positionY, positionParentY, widthRepartition, widthParentRepartition, paddingLeft, marginLeft, paddingLeftParent, marginLeftParent, largeurNoeud, largeurNoeudParent, positionX, positionParentX, indexNoeudParent;
    private string couleurAffichageCercle,couleurAffichageTexte,couleurBloquer,couleurNonConsulter,couleurConsulter,couleurCompleter,couleurTexteBloquer,couleurTexteNonConsulter,couleurTexteConsulter,couleurTexteCompleter;



    private GrapheView[] noeudsTest;


    <!--
        fonction : initialise les variables du components pour eviter les references nulls et appele les fonction de trie pour organiser les noeuds de la bonne facon.
        variables :
            avant boucle : 
                initFinis : est false tant que la fonction n'est pas finis, est utiliser dans l'affichage pour s'assurer que l'initialisation est terminer
                debug : definis si le mode debug est activer ou non. creer des données de test si il est active
                viewboxDictionary : garde en memoire les valeurs de la viewbox utiliser dans la balise svg
                sizeSvgDictionary : garde en memoire la taille de la balise svg, est ajuster a chaque changement de taille de la balise
                startPointsDictionary : voir commentaire de OnMouseDown()
                startPointsAbsoluteDictionary : voir commentaire de OnMouseDown()
                endPointsDictionary : voir commentaire de OnMouseMove()
                scaleZoom : voir commentaire OnWheelMove()
                displayHover : voir commentaire OnMouseOver()
                liaisonSecHover : list des liaison secondaire des noeuds a afficher dans le rect hover
                xBordureHover : coordonne en x du cercle qui sert a faire la bordure
                yBordureHover : coordonne en y du cercle qui sert a faire la bordure
                shouldReRender : valeur qui precise au visuel si il doit render de nouveau apres une fonction appeler lors d'un evenement blazor VU QU'ON PEUT PAS LES FUCKING DESACTIVER, A CHAQUE CALL Y RERENDER CE QUI REND IMPOSSIBLE L'UTILISATION DE OnMouseMove, A CHAQUE FUCKING PIXEL TU RERENDER TOUT AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                handler : sert a creer le httpClient
                httpClient : creer la base necessaire a la creation du client
                client : entité qui s'occupe de la communication avec l'api en utilisant nswag
                noeudAffiche : resultat retourner par la requete a la view GrapheView. utlise l'id du graphe pour recuperer tout les informations necessaire a l'affichage des noeuds qu'il lui sont assoscier
                infoHover : resultat retourner par la requete a la view HoverView. utlise l'id du graphe pour recuperer tout les informations necessaire a l'affichage du hover des noeuds qu'il lui sont assoscier
                noeudComplete : nb de noeud completer dans le graphe par l'etudiant
                pourcentageCompleter : pourcentage de noeud completer
                enumerator : enumerator qui sert a boucler dans une ICollection
                topNoeudRecommander : liste de 3 noeuds prioritaire sélectionner grace a un algorithme(voir UpdateGraphe). priorise les noeuds qui en bloque d'autre et les noeud les plus proches de la racine


            dans la boucle while :  
                structureGraphe : tableau 2d qui contient tous les noeuds apres le tries. utiliser lors de l'affichage
                structureGrapheTemporaire : tableau 2d utiliser pour s'adapter a la taille qui change et enregistrer les donnée du tableau principale
                etage : garde en memoire l'etage sur lequel vas le noeud utliser lors de la boucle foreach
                noeudsParEtages : tableau qui garde en memoire le nombre de noeuds par etages pour adapter la taille de structureGraphe
                noeudsParEtagesTemporaire : tableau qui s'ajuste a la taille necessaire et qui enregistre les données du tableau principale
    -->
    protected async override void OnInitialized()
    {
        Console.WriteLine("graphe initialized");
        initFinis = false;
        debug = false;
       

        updateService.RefreshRequested += this.RefreshState;


        viewboxDictionary.Add("x", 0);
        viewboxDictionary.Add("y", 0);
        viewboxDictionary.Add("width", 0);
        viewboxDictionary.Add("height", 0);

        sizeSvgDictionary.Add("width", 0);
        sizeSvgDictionary.Add("height", 0);

        startPointsDictionary.Add("x", 0);
        startPointsDictionary.Add("y", 0);

        startPointsAbsoluteDictionary.Add("x", 0);
        startPointsAbsoluteDictionary.Add("y", 0);

        endPointsDictionary.Add("x", 0);
        endPointsDictionary.Add("y", 0);

        scaleZoom = 1;
        topNoeudRecommander = new List<GrapheView>();



        displayHover = "hidden";
        liaisonSecHover = new string[0];
        xBordureHover = 0;
        yBordureHover = 0;

        shouldReRender = true;

        var handler = new HttpClientHandler();
        handler.ClientCertificateOptions = ClientCertificateOption.Manual;
        handler.ServerCertificateCustomValidationCallback =
            (httpRequestMessage, cert, cetChain, policyErrors) =>
            {
                return true;
            };
        httpClient = new HttpClient(handler);


        httpClient.BaseAddress = new Uri("https://p22e1api-dicjprojet.cegepjonquiere.ca/");
        client = new Client(httpClient);


        UpdateGraphe();

    }

    <!--
        fonction : mettre a jour les noeuds et autres valeur logistiques du graphe avec les données stocker dans le sessionStorage
        variables : 
            sessionStorage : service de stockage du projet. fonctionne comme un dictionnaire(key-value)
    -->
    private async void UpdateGraphe()
    {
        try
        {
            if(sessionStorage != null)
            {
                if(await sessionStorage.ContainKeyAsync("idGraphe") && await sessionStorage.GetItemAsync<int>("idGraphe") != 0)
                {
                    idGraphe = await sessionStorage.GetItemAsync<int>("idGraphe");

                    noeudAffiche = client.GrapheView2Async(idGraphe).Result;
                    infoHover = client.Hover2Async(idGraphe).Result;
                    noeudComplete = noeudAffiche.Where(n => n.CodeStatus == 4).Count();
                    pourcentageCompleter = (int)Math.Round((double)noeudComplete * 100 / (noeudAffiche.Count() - 1));

                    enumerator = noeudAffiche.GetEnumerator();

                    //données de test.
                    if(debug)
                    {
                        noeudsTest = new GrapheView[55];

                        for(int i = 0; i < noeudsTest.Length; i++)
                        {
                            noeudsTest[i] = new GrapheView(){Id = i,Code = "noeud" + i};
                        }

                        noeudsTest[0].LiaisonPrincipal = 0;

                        noeudsTest[1].LiaisonPrincipal = (int)noeudsTest[0].Id;
                        noeudsTest[2].LiaisonPrincipal = (int)noeudsTest[0].Id;

                        noeudsTest[3].LiaisonPrincipal = (int)noeudsTest[2].Id;
                        noeudsTest[4].LiaisonPrincipal = (int)noeudsTest[1].Id;
                        noeudsTest[5].LiaisonPrincipal = (int)noeudsTest[2].Id;

                        noeudsTest[6].LiaisonPrincipal = (int)noeudsTest[5].Id;
                        noeudsTest[7].LiaisonPrincipal = (int)noeudsTest[3].Id;
                        noeudsTest[8].LiaisonPrincipal = (int)noeudsTest[4].Id;
                        noeudsTest[9].LiaisonPrincipal = (int)noeudsTest[5].Id;

                        noeudsTest[10].LiaisonPrincipal = (int)noeudsTest[8].Id;
                        noeudsTest[11].LiaisonPrincipal = (int)noeudsTest[6].Id;
                        noeudsTest[12].LiaisonPrincipal = (int)noeudsTest[9].Id;
                        noeudsTest[13].LiaisonPrincipal = (int)noeudsTest[7].Id;
                        noeudsTest[14].LiaisonPrincipal = (int)noeudsTest[6].Id;

                        noeudsTest[15].LiaisonPrincipal = (int)noeudsTest[10].Id;
                        noeudsTest[16].LiaisonPrincipal = (int)noeudsTest[10].Id;
                        noeudsTest[17].LiaisonPrincipal = (int)noeudsTest[12].Id;
                        noeudsTest[18].LiaisonPrincipal = (int)noeudsTest[11].Id;
                        noeudsTest[19].LiaisonPrincipal = (int)noeudsTest[12].Id;
                        noeudsTest[20].LiaisonPrincipal = (int)noeudsTest[14].Id;

                        noeudsTest[21].LiaisonPrincipal = (int)noeudsTest[17].Id;
                        noeudsTest[22].LiaisonPrincipal = (int)noeudsTest[16].Id;
                        noeudsTest[23].LiaisonPrincipal = (int)noeudsTest[15].Id;
                        noeudsTest[24].LiaisonPrincipal = (int)noeudsTest[16].Id;
                        noeudsTest[25].LiaisonPrincipal = (int)noeudsTest[18].Id;
                        noeudsTest[26].LiaisonPrincipal = (int)noeudsTest[19].Id;
                        noeudsTest[27].LiaisonPrincipal = (int)noeudsTest[20].Id;

                        noeudsTest[28].LiaisonPrincipal = (int)noeudsTest[27].Id;
                        noeudsTest[29].LiaisonPrincipal = (int)noeudsTest[24].Id;
                        noeudsTest[30].LiaisonPrincipal = (int)noeudsTest[26].Id;
                        noeudsTest[31].LiaisonPrincipal = (int)noeudsTest[23].Id;
                        noeudsTest[32].LiaisonPrincipal = (int)noeudsTest[25].Id;
                        noeudsTest[33].LiaisonPrincipal = (int)noeudsTest[22].Id;
                        noeudsTest[34].LiaisonPrincipal = (int)noeudsTest[21].Id;
                        noeudsTest[35].LiaisonPrincipal = (int)noeudsTest[21].Id;

                        noeudsTest[36].LiaisonPrincipal = (int)noeudsTest[31].Id;
                        noeudsTest[37].LiaisonPrincipal = (int)noeudsTest[29].Id;
                        noeudsTest[38].LiaisonPrincipal = (int)noeudsTest[34].Id;
                        noeudsTest[39].LiaisonPrincipal = (int)noeudsTest[35].Id;
                        noeudsTest[40].LiaisonPrincipal = (int)noeudsTest[32].Id;
                        noeudsTest[41].LiaisonPrincipal = (int)noeudsTest[33].Id;
                        noeudsTest[42].LiaisonPrincipal = (int)noeudsTest[29].Id;
                        noeudsTest[43].LiaisonPrincipal = (int)noeudsTest[28].Id;
                        noeudsTest[44].LiaisonPrincipal = (int)noeudsTest[35].Id;

                        noeudsTest[45].LiaisonPrincipal = (int)noeudsTest[38].Id;
                        noeudsTest[46].LiaisonPrincipal = (int)noeudsTest[37].Id;
                        noeudsTest[47].LiaisonPrincipal = (int)noeudsTest[40].Id;
                        noeudsTest[48].LiaisonPrincipal = (int)noeudsTest[44].Id;
                        noeudsTest[49].LiaisonPrincipal = (int)noeudsTest[42].Id;
                        noeudsTest[50].LiaisonPrincipal = (int)noeudsTest[39].Id;
                        noeudsTest[51].LiaisonPrincipal = (int)noeudsTest[42].Id;
                        noeudsTest[52].LiaisonPrincipal = (int)noeudsTest[40].Id;
                        noeudsTest[53].LiaisonPrincipal = (int)noeudsTest[44].Id;
                        noeudsTest[54].LiaisonPrincipal = (int)noeudsTest[41].Id;
                    }



                    structureGraphe = new GrapheView[][] {};
                    structureGrapheTemporaire = new GrapheView[][] {};
                    noeudsParEtages = new int[] {};
                    noeudsParEtagesTemporaire = new int[] {};




                    while(enumerator.MoveNext())
                    {
                        int etage = 0;
                        GrapheView noeud = enumerator.Current;

                        etage = CalculEtage(noeud, etage);

                        if(etage >= noeudsParEtages.Length)
                        {
                            noeudsParEtagesTemporaire = new int[etage + 1];
                            for(int l = 0; l < noeudsParEtages.Length; l++)
                            {
                                noeudsParEtagesTemporaire[l] = noeudsParEtages[l];
                            }
                            noeudsParEtages = noeudsParEtagesTemporaire;
                        }
                        noeudsParEtages[etage]++;

                        structureGrapheTemporaire = new GrapheView[noeudsParEtages.Length][];

                        for(int e = 0; e < structureGrapheTemporaire.Length; e++)
                        {
                            structureGrapheTemporaire[e] = new GrapheView[noeudsParEtages[e]];
                        }

                        for(int j = 0; j < structureGraphe.Length;j++)
                        {
                            for(int k = 0; k < structureGraphe[j].Length;k++)
                            {
                                structureGrapheTemporaire[j][k] = structureGraphe[j][k];
                            }
                        }

                        structureGraphe = structureGrapheTemporaire;

                        structureGraphe[etage][noeudsParEtages[etage] - 1] = noeud;

                    }

                    structureGraphe = TrieTblNoeuds(structureGraphe);

                    topNoeudRecommander = new List<GrapheView>();

                    foreach(GrapheView noeud in noeudAffiche.Where(n => n.CodeStatus == 1).Where(n => n.Disponibilite < DateTimeOffset.Now))
                    {
                        foreach(HoverView hover in infoHover.Where(h => h.Id == noeud.Id).Where(h => noeudAffiche.Where(n => n.CodeStatus != 1).Where(n => n.CodeStatus != 4).Any(n => n.Code == h.CodeParent)))
                        {
                            if(hover.CodeParent != null)
                            {
                                if(!topNoeudRecommander.Any(t => t.Code == hover.CodeParent))
                                {
                                    topNoeudRecommander.Add(new GrapheView(){Id = noeudAffiche.Where(n => n.Code == hover.CodeParent).Where(n => n.GrapheId == hover.GrapheId).Select(n => n.Id).FirstOrDefault(), Code = hover.CodeParent});        
                                }

                            }

                        }

                    }

                    if(topNoeudRecommander.Count > 3)
                    {
                        topNoeudRecommander = topNoeudRecommander.Take(3).ToList();
                    }
                    else if(topNoeudRecommander.Count < 3)
                    {
                        for(int j = 0; j < structureGraphe.GetLength(0); j++)
                        {
                            if(topNoeudRecommander.Count < 3)
                            {
                                for (int k = 0; k < structureGraphe[j].Length; k++)
                                {
                                    if(topNoeudRecommander.Count < 3 && structureGraphe[j][k].CodeStatus != 1 && structureGraphe[j][k].CodeStatus != 4)
                                    {
                                        if(!topNoeudRecommander.Any(t => t.Id == structureGraphe[j][k].Id))
                                        {
                                            topNoeudRecommander.Add(structureGraphe[j][k]);    
                                        }
                                    }
                                }
                            }
                        }
                    }



                    initFinis = true;

                    Console.WriteLine("param finis statehaschanged");
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
        catch(JSDisconnectedException e)
        {
            //ignore voir https://stackoverflow.com/questions/72488563/blazor-server-side-application-throwing-system-invalidoperationexception-javas
        }

    }



    /*
    * fonction : recupere la taille de la balise svg pour adapter les valeurs visuel a la taille de la page
    * variables : 
    *   element : objet qui garde en memoire la taille de la balise svg
    *   viewboxDictionary : voir commentaire OnInitialized()
    *   sizeSvgDictionary : voir commentaire OnInitialized()
    *   rayonCercleSvg : correspond a la taille du rayon des cercles utiliser pour afficher les noeuds dans le graphe
    *   widthRectLegend : largeur du rectangle contenant la légende du graphe
    *   heightRectLegend : hauteur du rectangle contenant la legende du graphe
    *   heightRectStats : hauteur du rectangle contenant les statistiques du graphe
    * 
    */
    protected override async void OnAfterRender(bool firstRender)
    {
        if(initFinis)
        {
            try
            {
                element = await JSRuntim.InvokeAsync<BoundingClientRect>("GetSizeElement", "svgGraphiqueComponent");
            }
            catch(Exception e)
            {
                await InvokeAsync(StateHasChanged);
            }




            if(Math.Round(element.Width) > sizeSvgDictionary["width"] + 20 || Math.Round(element.Width) < sizeSvgDictionary["width"] - 20 || Math.Round(element.Height) > sizeSvgDictionary["height"] + 20 || Math.Round(element.Height) < sizeSvgDictionary["height"] - 20)
            {
                //JSRuntim.InvokeVoidAsync("console.log","changement de taille du svg");
                sizeSvgDictionary["width"] = (int)Math.Round(element.Width);
                sizeSvgDictionary["height"] = (int)Math.Round(element.Height);

                viewboxDictionary["width"] = sizeSvgDictionary["width"];
                viewboxDictionary["height"] = sizeSvgDictionary["height"];
                viewboxDictionary["x"] = 0;
                viewboxDictionary["y"] = 0;

                if(element.Width <= element.Height)
                {
                    rayonCercleSvg = (int)Math.Round(element.Width * 4 / 100);    
                }
                else
                {
                    rayonCercleSvg = (int)Math.Round(element.Height * 4 / 100);
                }

                widthRectLegend = (int)Math.Round((double)(15 * viewboxDictionary["width"]) / 100);
                heightRectLegend = (int)Math.Round((double)(28 * viewboxDictionary["height"]) / 100);

                heightRectStats =  (int)Math.Round((double)(30 * viewboxDictionary["height"]) / 100);

                noeudsCoordonneDictionnary.Clear();



                await InvokeAsync(StateHasChanged);
            }
        }

    }

    /*
    * fonction : permet de zoomer dans le graphe
    * variable :
    *   widthViewbox : largeur de la viewbox actuel
    *   heightViewbox : hauteur de la viewbox
    *   mouseX : position de la souris sur l'axe horizontale par rapport a l'element dans lequel il est
    *   mouseY : position de la souris sur l'axe verticale par rapport a l'element dans lequel il est
    *   deplacementWidth : correspond a la modification de la largeur de la viewbox en pixel
    *   deplacementHeight : correspond a la modification de la hauteur de la viewbox en pixel
    *   deplacementX : correspond au deplacement en x de la viewbox en pixel(attention le deplacement est inverser) 
    *   deplacementY : correspond au deplacement en y de la viewbox en pixel(attention le deplacement est inverser) 
    *   scaleZoom : correspond a l'intensite du zoom actuelle
    * 
    * details : 
    *   le premier if verifie si l'utilisateur pese sur la touche shift(Maj▲) pour éviter les conflicts avec le scroll normal
    *   le deuxieme if verfie si l'utilisateur ne depasse pas la limite de dezoom qui est 2 fois la taille de l'element
    */
    public void OnWheelMove(WheelEventArgs mouse)
    {
        if(mouse.ShiftKey)
        {
            widthViewbox = viewboxDictionary["width"];
            heightViewbox = viewboxDictionary["height"];
            mouseX = mouse.OffsetX;
            mouseY = mouse.OffsetY;


            deplacementWidth = widthViewbox * Math.Sign(mouse.DeltaY) * forceZoom;
            deplacementHeight = heightViewbox * Math.Sign(mouse.DeltaY) * forceZoom;

            deplacementX = deplacementWidth * mouseX / sizeSvgDictionary["width"];
            deplacementY = deplacementHeight * mouseY / sizeSvgDictionary["height"];

            viewboxDictionary["x"] -= (int)Math.Round(deplacementX);
            viewboxDictionary["y"] -= (int)Math.Round(deplacementY);
            viewboxDictionary["width"] += (int)Math.Round(deplacementWidth);
            viewboxDictionary["height"] += (int)Math.Round(deplacementHeight);

            if(viewboxDictionary["width"] > (sizeSvgDictionary["width"] * 2) && deplacementWidth > 0)
            {
                viewboxDictionary["width"] = sizeSvgDictionary["width"] * 2;
                viewboxDictionary["height"] = sizeSvgDictionary["height"] * 2;
                viewboxDictionary["x"] += (int)Math.Round(deplacementX);
                viewboxDictionary["y"] += (int)Math.Round(deplacementY);
            }

            scaleZoom = (double)sizeSvgDictionary["width"] / (double)viewboxDictionary["width"];
            //JSRuntim.InvokeVoidAsync("console.log",scaleZoom);
        }

    }

    /*
    * fonction : definis les variables des dictionnaires startPointsDictionary et startPointsAbsoluteDictionary avec les valeurs de positions de la souris pour qu'ils soit utiliser dans les calculs lors du deplacement de la souris
    * variables : 
    *   leftClicPress : utiliser pour verifier que c'est le clic gauche qui est enfoncer dans la fonction OnMouseUp
    *   starPointsDictionary : utiliser comme point de depart lors du calcul de deplacement de la souris
    *   startPointsAbsoluteDictionary : utiliser pour garder en memoire le point de depart initiale puisque que startPoints est modifier. utiliser dans la fonction OnClick
    */
    public void OnMouseDown(MouseEventArgs mouse)
    {
        if(mouse.Buttons == 1)
        {
            startPointsDictionary["x"] = (int)Math.Round(mouse.OffsetX);
            startPointsDictionary["y"] = (int)Math.Round(mouse.OffsetY);

            startPointsAbsoluteDictionary["x"] = (int)Math.Round(mouse.OffsetX);
            startPointsAbsoluteDictionary["y"] = (int)Math.Round(mouse.OffsetY);

            leftClicPress = true;
        }
    }

    /*
    * fonction : calcul la distance fait par la souris et modifie la viewbox en conséquence
    * variable :
    *   endPointsDictionary : correspond a la position de la souris lors de l'appele de la fonction, donc apres le mouvement
    *   translationX : correspond au deplacement de la souris en x entre les données de startPointsDictionary et endPointsDictionary modifier selon le zoom
    *   translationY : correspond au deplacement de la souris en y entre les données de startPointsDictionary et endPointsDictionary modifier selon le zoom
    * details :
    *   on additionne a la viewbox plutot que soustraire car on veut effectuer le deplacement dans la direction inverse
    *   on ajuste les valeurs de startPointsDictionary pour qu'elles corresponde a la position finale
    *   le deuxieme if verifie si l'on depasse la taille de l'element svg, si oui, on annule les modification
    */
    public void OnMouseMove(MouseEventArgs mouse)
    {
        if(mouse.Buttons == 1)
        {
            endPointsDictionary["x"] = (int)Math.Round(mouse.OffsetX);
            endPointsDictionary["y"] = (int)Math.Round(mouse.OffsetY);

            translationX = (startPointsDictionary["x"] - endPointsDictionary["x"]) / scaleZoom;
            translationY = (startPointsDictionary["y"] - endPointsDictionary["y"]) / scaleZoom;


            viewboxDictionary["x"] += (int)Math.Round(translationX);
            viewboxDictionary["y"] += (int)Math.Round(translationY);


            startPointsDictionary["x"] -= (int)Math.Round(translationX);
            startPointsDictionary["y"] -= (int)Math.Round(translationY);

            if(viewboxDictionary["x"] > sizeSvgDictionary["width"] || viewboxDictionary["x"] < sizeSvgDictionary["width"] * -1 || viewboxDictionary["y"] > sizeSvgDictionary["height"] || viewboxDictionary["y"] < sizeSvgDictionary["height"] * -1)
            {
                viewboxDictionary["x"] -= (int)Math.Round(translationX);
                viewboxDictionary["y"] -= (int)Math.Round(translationY);

                startPointsDictionary["x"] += (int)Math.Round(translationX);
                startPointsDictionary["y"] += (int)Math.Round(translationY);
            }

        }
        else
        {
            shouldReRender = false;
        }

    }

    /*
    * fonction : meme chose que la fonction OnMouseMove et change la valeur de leftClicPress. 
    * details : voir si c'est possible de l'enlever
    */
    public void OnMouseUp(MouseEventArgs mouse)
    {
        if(leftClicPress)
        {
            endPointsDictionary["x"] = (int)Math.Round(mouse.OffsetX);
            endPointsDictionary["y"] = (int)Math.Round(mouse.OffsetY);

            translationX = (startPointsDictionary["x"] - endPointsDictionary["x"]) / scaleZoom;
            translationY = (startPointsDictionary["y"] - endPointsDictionary["y"]) / scaleZoom;

            viewboxDictionary["x"] += (int)Math.Round(translationX);
            viewboxDictionary["y"] += (int)Math.Round(translationY);
        }
        leftClicPress = false;
    }

    /*
    * fonction : calcul la distance entre l'etage du noeud et l'etage du noeud originelle
    */
    private int CalculEtage(GrapheView noeud, int etage)
    {
        if(noeud.LiaisonPrincipal == 0)
        {
            return etage;
        }
        else
        {
            return CalculEtage(noeudAffiche.Where(n => n.Id == noeud.LiaisonPrincipal).FirstOrDefault(), etage + 1);
        }
    }
    
    /*
    * fonction : trie chaque ligne du tableau pour que les enfants soit dans le meme ordre que leur parent
    * variables : 
    *   tblTemporaire : tableau contenant les index des parents des noeuds de chaque ligne. le tableau de noeud est trier en meme temps que lui pour les mettres dans l'ordre
    */
    private GrapheView[][] TrieTblNoeuds(GrapheView[][] tableau)
    {
        int[] tblTemporaire;

        for(int j = 0; j < tableau.Length; j++)
        {
            if(j != 0)
            {
                tblTemporaire = new int[tableau[j].Length];

                for(int i = 0; i < tableau[j].Length; i++)
                {
                    tblTemporaire[i] = Array.IndexOf(tableau[j - 1], Array.Find(tableau[j -1],noeud => noeud.Id == tableau[j][i].LiaisonPrincipal));
                }

                Array.Sort(tblTemporaire, tableau[j]);
            }
        }

        return tableau;
    }

    /*
    * fonction : definit la taille et la position du rectangle hover, le contenu a afficher dans celui-ci et definit la visibilite a 'visible'
    * variables : 
    *   x : coordonne en x du noeud sur lequel passe la souris
    *   y : corrdonne en y du noeud sur lequel passe la souris
    *   id : id du noeud sur lequel passe la souris
    *   widthRectHover : largeur qu'auras le rectangle hover. varie selon le zoom et la taille de la page
    *   heightRectHover : hauteur qu'auras le rectangle hover. varie selon le zoom et la taille de la page
    *   positionXRectHover : position sur l'axe horizontal du coin superieur gauche du rectangle hover
    *   pointAXPolyHover : position sur l'axe horizontal du points A constituants le polygones(triangle) entre le noeud et le rectangle hover
    *   pointBXPolyHover : position sur l'axe horizontal du points B constituants le polygones(triangle) entre le noeud et le rectangle hover
    *   pointCXPolyHover : position sur l'axe horizontal du points C constituants le polygones(triangle) entre le noeud et le rectangle hover
    *   positionYRectHover : position sur l'axe verticale du coin superieur gauche du rectangle hover
    *   pointAYPolyHover : position sur l'axe verticale du points A constituants le polygones(triangle) entre le noeud et le rectangle hover
    *   pointBYPolyHover : position sur l'axe verticale du points B constituants le polygones(triangle) entre le noeud et le rectangle hover
    *   pointCYPolyHover : position sur l'axe verticale du points C constituants le polygones(triangle) entre le noeud et le rectangle hover
    *   noeudHover : ensemble des informations a afficher, trouver en utilisant l'id du noeud sur lequel passe la souris
    *   nomHover : code du noeud a afficher dans le rectangle hover
    *   descHover : description du noeud a afficher dans le rectangle hover
    *   ptsHover : sommes des points de toutes les pages assoscier au noeud a afficher dans le recatngle hover
    *   liaisonSecHover : tableau constituer de toute les liaison secondaire du noeud, si il n'en n'as pas remplace la premiere entré du tableau a 'aucune'
    *   displayHover : boolean qui garde en memoire si le rectangle hover doit etre afficher ou non
    * 
    * details : 
    *   les ifs servent a verifier que le rectangle ne depasse pas la balise svg, si oui il inverse les valeurs d'affichage, donc au lieu de l'afficher en haut du noeud, il l'affiche en bas
    */
    private void OnMouseOverNoeuds(int id)
    {

        widthRectHover = (int)Math.Round((double)(15 * viewboxDictionary["width"]) / 100);
        heightRectHover = (int)Math.Round((double)(15 * viewboxDictionary["height"]) / 100);


        if(noeudsCoordonneDictionnary[id].x + (widthRectHover + rayonCercleSvg) > element.Width)
        {
            positionXRectHover = noeudsCoordonneDictionnary[id].x - widthRectHover - rayonCercleSvg;
            pointAXPolyHover = noeudsCoordonneDictionnary[id].x - (int)Math.Round((Math.Cos(45) * rayonCercleSvg));
            pointBXPolyHover = noeudsCoordonneDictionnary[id].x - (int)Math.Round(rayonCercleSvg + (rayonCercleSvg - Math.Cos(45) * rayonCercleSvg));
            pointCXPolyHover = noeudsCoordonneDictionnary[id].x - rayonCercleSvg;
        }
        else
        {
            positionXRectHover = noeudsCoordonneDictionnary[id].x + rayonCercleSvg;
            pointAXPolyHover = noeudsCoordonneDictionnary[id].x + (int)Math.Round((Math.Cos(45) * rayonCercleSvg));
            pointBXPolyHover = noeudsCoordonneDictionnary[id].x + (int)Math.Round(rayonCercleSvg + (rayonCercleSvg - Math.Cos(45) * rayonCercleSvg));
            pointCXPolyHover = noeudsCoordonneDictionnary[id].x + rayonCercleSvg;
        }

        if(noeudsCoordonneDictionnary[id].y - (heightRectHover + rayonCercleSvg) < 0)
        {
            positionYRectHover = noeudsCoordonneDictionnary[id].y + rayonCercleSvg;
            pointAYPolyHover = noeudsCoordonneDictionnary[id].y + (int)Math.Round(Math.Sin(45) * rayonCercleSvg);
            pointBYPolyHover = noeudsCoordonneDictionnary[id].y + rayonCercleSvg;
            pointCYPolyHover = noeudsCoordonneDictionnary[id].y + (int)Math.Round(rayonCercleSvg + (rayonCercleSvg - (Math.Sin(45) * rayonCercleSvg)));
        }
        else
        {
            positionYRectHover = noeudsCoordonneDictionnary[id].y - heightRectHover - rayonCercleSvg;
            pointAYPolyHover = noeudsCoordonneDictionnary[id].y - (int)Math.Round(Math.Sin(45) * rayonCercleSvg);
            pointBYPolyHover = noeudsCoordonneDictionnary[id].y - rayonCercleSvg;
            pointCYPolyHover = noeudsCoordonneDictionnary[id].y - (int)Math.Round(rayonCercleSvg + (rayonCercleSvg - (Math.Sin(45) * rayonCercleSvg)));
        }

        noeudHover = infoHover.Where(g => g.Id == id).FirstOrDefault();
        nomHover = noeudHover.Code;
        descHover = noeudHover.Description;
        ptsHover = noeudHover.PtsTotal;

        liaisonSecHover = infoHover.Where(g => g.Id == id).Select(g => g.CodeParent).ToArray();


        if(liaisonSecHover[0] == null)
        {
            //liaisonSecHover = new string[1];
            liaisonSecHover[0] = "aucune";
        }

        xBordureHover = noeudsCoordonneDictionnary[id].x;
        yBordureHover = noeudsCoordonneDictionnary[id].y;

        displayHover = "visible";


    }
   
    /*
    * fonction : change la valeur de visibilite a hidden pour l'element avec l'id recu en parametre
    * variables : 
    *   displayHover : voir commentaire OnMouseOverNoeud()
    */
    private void OnMouseOut()
    {
        displayHover = "hidden";
    }

    /*
    * fonction : verifie si l'utilisateur n'as pas deplacer sa souris, change le status du noeud cliquer si son status egale 2, puis l'envoie vers la page de theorie correspondante a l'id cliquer
    * variables : 
    *   startPointsAbsoluteDictionary : voir commentaire OnMouseDown()
    *   endPointsDictionary : voir commentaire OnMouseMove()
    *   noeudCliquer : correspond au noeuds cliquer. permet de verifier ses informations pour effectuer les bonnes action. ex. changer son status
    *   updateNoeud : noeud creer a partir du noeud cliquer. il est utiliser lors de la requete pour modifier la bd. toute les valeurs manquante egale a null et son gerer au niveau du controller 
    */
    private async void OnClick(int? id)
    {
        if((endPointsDictionary["x"] < startPointsAbsoluteDictionary["x"] + 15) && (endPointsDictionary["x"] > startPointsAbsoluteDictionary["x"] - 15) && (endPointsDictionary["y"] < startPointsAbsoluteDictionary["y"] + 15) && (endPointsDictionary["y"] > startPointsAbsoluteDictionary["y"] - 15))
        {
            GrapheView noeudCliquer = noeudAffiche.Where(n => n.Id == id).FirstOrDefault();

            if(noeudCliquer.LiaisonPrincipal != 0 && noeudCliquer.CodeStatus != 1)
            {
                if(noeudCliquer.CodeStatus == 2)
                {
                    Noeud updateNoeud = new Noeud()
                    {
                        Id = noeudCliquer.Id,
                        Status = 3,
                        Code = noeudCliquer.Code

                    };
                    client.ReadResponseAsString = true;
                    await client.NoeudsPUTAsync(noeudCliquer.Id, updateNoeud);
                }
                NavigationManager.NavigateTo("/theorie/" + id);
            }
        }
    }

    /*
    * fonction : remet les valeurs de la viewbox a zero
    * variables : 
    *   viewboxDictionary : voir commentaire OnInitialized()
    *   scaleZoom : voir commentaire OnInitialized()
    */
    private void ResetViewbox()
    {
        viewboxDictionary["x"] = 0;
        viewboxDictionary["y"] = 0;
        viewboxDictionary["width"] = sizeSvgDictionary["width"];
        viewboxDictionary["height"] = sizeSvgDictionary["height"];
        scaleZoom = 1;
    }

    /*
    * fonction : augmenter le zoom du graphe sans utiliser la roulette
    */
    private async void AugmenterZoom()
    {
        viewboxDictionary["x"] += (int)Math.Round((viewboxDictionary["width"] * 0.1) * (sizeSvgDictionary["width"] / 2) / sizeSvgDictionary["width"]);
        viewboxDictionary["y"] += (int)Math.Round((viewboxDictionary["height"] * 0.1) * (sizeSvgDictionary["height"] / 2) / sizeSvgDictionary["height"]);
        viewboxDictionary["width"] -= (int)Math.Round(viewboxDictionary["width"] * 0.1);
        viewboxDictionary["height"] -= (int)Math.Round(viewboxDictionary["height"] * 0.1);

        scaleZoom = (double)sizeSvgDictionary["width"] / (double)viewboxDictionary["width"];

        await InvokeAsync(StateHasChanged);
    }

    /*
    * fonction : reduire le zoom du graphe sans utiliser la roulette
    */
    private async void ReduireZoom()
    {
        if(viewboxDictionary["width"] < (sizeSvgDictionary["width"] * 2))
        {
            viewboxDictionary["x"] -= (int)Math.Round((viewboxDictionary["width"] * 0.1) * (sizeSvgDictionary["width"] / 2) / sizeSvgDictionary["width"]);
            viewboxDictionary["y"] -= (int)Math.Round((viewboxDictionary["height"] * 0.1) * (sizeSvgDictionary["height"] / 2) / sizeSvgDictionary["height"]);
            viewboxDictionary["width"] += (int)Math.Round(viewboxDictionary["width"] * 0.1);
            viewboxDictionary["height"] += (int)Math.Round(viewboxDictionary["height"] * 0.1);

        }
        if(viewboxDictionary["width"] > (sizeSvgDictionary["width"] * 2))
        {
            viewboxDictionary["width"] = sizeSvgDictionary["width"] * 2;
            viewboxDictionary["height"] = sizeSvgDictionary["height"] * 2;
        }
        scaleZoom = (double)sizeSvgDictionary["width"] / (double)viewboxDictionary["width"];

        await InvokeAsync(StateHasChanged);

    }

    <!--
        fonction : change la page pour celle d'aide
    -->
    private void MoveToAide()
    {
        NavigationManager.NavigateTo("/graphe/aide");
    }

    <!--
        fonction appeler lorsqu'un changement d'etat est detecter. definis si l'affichage doit se recharger
    -->
    protected override bool ShouldRender()
    {
        if(shouldReRender)
        {
            return true;
        }
        else
        {
            shouldReRender = true;
            return false;
        }
    }

    public async void RefreshState()
    {
        UpdateGraphe();
    }

    <!-- 
        fonction : classe permettant de stocker les coordonnes x et y d'Affichage des noeuds dans un objet
    -->
    private class Coordonne
    {
        public int x{ get; set; }
        public int y{ get; set; }
    }

    /*
     * fonction : permet d'enregistrer les valeurs de tailles d'un element dans un objet
     */
    public class BoundingClientRect
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double Top { get; set; }
        public double Right { get; set; }
        public double Bottom { get; set; }
        public double Left { get; set; }
    }

}
