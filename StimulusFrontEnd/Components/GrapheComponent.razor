@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntim
@inject Blazored.SessionStorage.ISessionStorageService sessionStorage
@inject IUpdateService updateService

@if(initFinis)
{
    couleurBloquer = "rgb(140,140,140)";
    couleurNonConsulter = "rgb(228, 231, 245)";
    couleurConsulter = "rgb(199,160,53)";
    couleurCompleter = "rgb(28, 90, 47)";  

    couleurTexteBloquer = "#0000FF";
    couleurTexteNonConsulter = "#0000FF";
    couleurTexteConsulter = "#0000FF";
    couleurTexteCompleter = "#0000FF";

    <div id="divGraphiqueComponent">

        <div id="divGrapheEntete" class="zoom">
            <p class="grapheEnteteElement" style="color:white;">zoom : @(Math.Round(scaleZoom * 100))%</p>
            <button class="grapheEnteteElement" style="font-size:15px" type="button" @onclick="AugmenterZoom">+</button>
            <button class="grapheEnteteElement" style="font-size:15px" type="button" @onclick="ReduireZoom">-</button>
            <button class="grapheEnteteElement" type="button" @onclick="ResetViewbox">réinitialiser</button>
            <button class="grapheEnteteElement" type="button" @onclick="MoveToAide">aide</button>

        </div>
        
        <svg id="svgGraphiqueComponent" style="user-select:none" viewBox=@(0 + " " + 0 + " " + sizeSvgDictionary["width"] + " " + sizeSvgDictionary["height"] + "") @onmousewheel="OnWheelMove" @onwheel="OnWheelMove" @onmousedown="OnMouseDown" @onmousemove="OnMouseMove" @onmouseup="OnMouseUp">
            <svg viewBox=@(viewboxDictionary["x"] + " " + viewboxDictionary["y"] + " " + viewboxDictionary["width"] + " " + viewboxDictionary["height"] + "")>
                <!--
                fonction : affiche le tableau 2d qui contients les noeuds.
                    la premiere boucle calcul la hauteur a laquelle les noeuds vont etre afficher pour chaque ligne(donc leur position en y)
                    la deuxieme boucle calcul le positionemment de chaque noeuds sur leur ligne(donc leur position en x)
                variables : 
                    premiere boucle : 
                        i : compteur de la premiere boucle
                        hauteurEtage : hauteur d'un etage du graphique, varie selo la taille et le nombre d'etage
                        paddingTop : espace au dessus du premiere etage du graphe pour fair plus jolie visuellement et pour eviter que le premier noeud soit decouper de moitier
                        positionY : correspond a la position verticale a laquelle les noeuds seront afficher(leur coordonnée y)
                        widthRepartition : corrrespond a la largeur sur laquel les noeuds seront repartie(permet de calculer la position de depart par rapport a la largeur de l'element svg)
                        paddingLeft : espace a gauche des noeuds d'un etage pour centrer les noeuds sur widthRepartition
                        marginLeft : espace a gauche de widthRepartion qui permet de centrer widthRepartition
                        largeurNoeud : espace qu'occupe un noeud sur widthRepartition, permet d'espacer les noeuds


                    deuxieme boucle :
                        j : compteur de la deuxieme boucle
                        positionX : correspond a la position horizontale a laquelle les noeuds seront afficher(leur coordonnée x)
                        iTemporaire : egale au compteur portant un nom similaire(utiliser lors de l'attribution des id dans les fonctions, utiliser les compteurs normaux ne fonctionne pas)
                        jTemporaire : egale au compteur portant un nom similaire(utiliser lors de l'attribution des id dans les fonctions, utiliser les compteurs normaux ne fonctionne pas)
                        couleurAffichage : couleur qu'aura le noeud pour l'affichage. change selon le statut
                        positionYTemporaire : egale a positionY. est utiliser dans les fonction assoscier aux noeuds, utiliser positionY ne fonctionne pas
                        positionXTemporaire : egale a positionX. est utiliser dans les fonction assoscier aux noeuds, utiliser positionX ne fonctionne pas
                        noeudsCoordonneDictionnary : dictionnaire contenant les coordonnes de tout les noeud du graphe. utilise leur id comme clé


                details : 
                    les positions des élements est en pixels car en pourcentage la viewbox agis differemment.
                    les balises <use> sont utiliser pour faire afficher les noeuds parent pardessus les lignes car sinon, les lignes etant dessiner apres, elles étaient afficher pardessus
                    la blaise svg affichant les noeuds est a l'interieur d'une autre balise svg, cela permet d'avoir plusieur couche de svg avec differente viewbox. utiliser pour toujours avoir l'entete au meme endroit
                    la formule mathematique qui calcul widthRepartition pourrais etre ameliorer
            -->   
                @{                              
                    hauteurEtage = (int)Math.Round((double)sizeSvgDictionary["height"] / structureGraphe.GetLength(0));
                    paddingTop = (int)Math.Round((double)hauteurEtage / 2);
                    positionY = 0;
                    widthRepartition = 0;
                    paddingLeft = 0;
                    marginLeft = 0;
                    largeurNoeud = 0;


                    positionX = 0;
                    couleurAffichageCercle = "";
                    couleurAffichageTexte = "";            
                }
                <circle visibility="@displayHover" cx="@xBordureHover" cy="@yBordureHover" r="@rayonCercleSvg" fill-opacity="0.0" fill="PatWasHere" stroke="#6e9cc4" stroke-width="10px" ></circle>

                @for(int i = 0; i < structureGraphe.GetLength(0); i++)
                {
                    positionY = (int)(hauteurEtage * i + paddingTop);

                    if(i > 0 && structureGraphe[i].Length >= 1 && structureGraphe[i].Length < 5)
                    {
                        widthRepartition = (int)Math.Round((double)((100 / (6 - structureGraphe[i].Length)) * sizeSvgDictionary["width"] / 100));
                    }
                    else if(structureGraphe[i].Length == 5)
                    {
                        widthRepartition = (int)Math.Round((double)sizeSvgDictionary["width"] / 100 * 62);
                    }
                    else if(structureGraphe[i].Length == 6)
                    {
                        widthRepartition = (int)Math.Round((double)sizeSvgDictionary["width"] / 100 * 73);
                    }
                    else if(structureGraphe[i].Length == 7)
                    {
                        widthRepartition = (int)Math.Round((double)sizeSvgDictionary["width"] / 100 * 84);
                    }
                    else if(structureGraphe[i].Length == 8)
                    {
                        widthRepartition = (int)Math.Round((double)sizeSvgDictionary["width"] / 100 * 95);
                    }
                    else
                    {
                        widthRepartition = sizeSvgDictionary["width"];
                    }                   

                    marginLeft = (int)Math.Round((double)(sizeSvgDictionary["width"] - widthRepartition) / 2);
                    paddingLeft = (int)Math.Round((double)(widthRepartition / structureGraphe[i].Length) / 2);

                    largeurNoeud = (int)Math.Round((double)widthRepartition / structureGraphe[i].Length);
            
                    for(int j = 0; j < structureGraphe[i].Length; j++)
                    {
                        positionX = marginLeft + (largeurNoeud * j) + paddingLeft;
                        int positionYTemporaire = positionY;
                        int positionXTemporaire = positionX;
                        int iTemporaire = i;
                        int jTemporaire = j;
                        if(structureGraphe[i][j].CodeStatus == 1)
                        {
                            couleurAffichageCercle = couleurBloquer;
                            couleurAffichageTexte = couleurTexteBloquer;
                        }
                        else if(structureGraphe[i][j].CodeStatus == 2)
                        {
                            couleurAffichageCercle = couleurNonConsulter;
                            couleurAffichageTexte = couleurTexteNonConsulter;
                        }
                        else if(structureGraphe[i][j].CodeStatus == 3)
                        {
                            couleurAffichageCercle = couleurConsulter;
                            couleurAffichageTexte = couleurTexteConsulter;
                        }
                        else if(structureGraphe[i][j].CodeStatus == 4)
                        {
                            couleurAffichageCercle = couleurCompleter;
                            couleurAffichageTexte = couleurTexteCompleter;
                        }

                        if(i >= 1)
                        {
                            <line x1="@positionX" y1="@positionY" x2="@(noeudsCoordonneDictionnary[structureGraphe[i][j].LiaisonPrincipal].x)" y2="@(noeudsCoordonneDictionnary[structureGraphe[i][j].LiaisonPrincipal].y)" style="stroke:rgb(100,100,100);stroke-width:2"></line>
                            <use href="@("#group" + structureGraphe[i][j].LiaisonPrincipal)" @onclick="() => OnClick((int)structureGraphe[iTemporaire][jTemporaire].LiaisonPrincipal)" @onmouseover="() => OnMouseOverNoeuds(structureGraphe[iTemporaire][jTemporaire].LiaisonPrincipal)" @onmouseout="() => OnMouseOut()"></use>
                    
                        }
                        <g id=@("group" + structureGraphe[i][j].Id) >
                            <circle id=@("noeud" + structureGraphe[i][j].Id) cx="@positionX" cy="@positionY" r="@rayonCercleSvg" fill="@couleurAffichageCercle" ></circle>
                            <text id=@("text" + structureGraphe[i][j].Id) x=@positionX y=@positionY text-anchor="middle" dominant-baseline="middle" fill="@couleurAffichageTexte" font-size="@(rayonCercleSvg / 2)" textLength="@(Math.Round(rayonCercleSvg * 1.8))" lengthAdjust="spacingAndGlyphs" >@(structureGraphe[i][j].Code)</text>
                            <circle id=@("noeudInv" + structureGraphe[i][j].Id) cx="@positionX" cy="@positionY" r="@rayonCercleSvg" fill-opacity="0.0" fill="PatWasHereTo" @onclick="() => OnClick(structureGraphe[iTemporaire][jTemporaire].Id)" @onmouseover="() => OnMouseOverNoeuds(structureGraphe[iTemporaire][jTemporaire].Id)" @onmouseout="() => OnMouseOut()"></circle>
                        </g>

                        if(!noeudsCoordonneDictionnary.ContainsKey(structureGraphe[i][j].Id))
                        {
                            noeudsCoordonneDictionnary.Add(structureGraphe[i][j].Id, new Coordonne() { x = positionX, y = positionY });
                        }
                        else
                        {
                            noeudsCoordonneDictionnary[structureGraphe[i][j].Id].x = positionX;
                            noeudsCoordonneDictionnary[structureGraphe[i][j].Id].y = positionY;
                        }
                    }
                }
                <rect visibility="@displayHover" x="@positionXRectHover" y="@positionYRectHover" width="@widthRectHover" height="@heightRectHover" fill="grey"></rect>
                <polygon visibility="@displayHover" points="@("" + pointAXPolyHover + "," + pointAYPolyHover + " " + pointBXPolyHover + "," + pointBYPolyHover + " " + pointCXPolyHover + "," + pointCYPolyHover)" fill="grey"></polygon>
        
                <foreignObject visibility="@displayHover" x="@positionXRectHover" y="@positionYRectHover" width="@(Math.Round(widthRectHover / 2.1))" height="@(heightRectHover / 3)"><p style="color:white; font-size:@(viewboxDictionary["width"] / 100)px;">nom: @nomHover</p></foreignObject>
                <foreignObject visibility="@displayHover" x="@(positionXRectHover + (widthRectHover / 2))" y="@positionYRectHover" width="@(widthRectHover / 2)" height="@(heightRectHover / 3)"><p style="color:white; font-size:@(viewboxDictionary["width"] / 100)px;">pts: @ptsHover</p></foreignObject>
                <foreignObject visibility="@displayHover" x="@positionXRectHover" y="@(positionYRectHover + (heightRectHover / 3))" width="@(Math.Round(widthRectHover / 2.2))" height="@((heightRectHover / 6) * 4)"> <p style="color:white; font-size:@(viewboxDictionary["width"] / 100)px;">desc: @descHover</p> </foreignObject>
                <foreignObject visibility="@displayHover" x="@(positionXRectHover + (widthRectHover / 2))" y="@(positionYRectHover + (heightRectHover / 3))" width="@(widthRectHover / 2)" height="@(heightRectHover / 6)"> <p style="color:white; font-size:@(viewboxDictionary["width"] / 100)px;">prérequis:</p> </foreignObject>            
                @for(int k =0;k < liaisonSecHover.Length;k++)
                {
                    <foreignObject visibility="@displayHover" x="@(positionXRectHover + (widthRectHover / 2))" y="@(positionYRectHover + ((heightRectHover / 6) * (k + 3)))" width="@(widthRectHover / 2)" height="@(heightRectHover / 6)"> <p style="color:white; font-size:@(viewboxDictionary["width"] / 100)px;">@liaisonSecHover[k]</p> </foreignObject>            
                }              
            </svg>
            <!--
                fonction : affichage de la legende et des statistique
                variables :
                    idTemporaire : egale a hover.id. est utiliser dans les fonction assoscier aux liens, utiliser hover.id ne fonctionne pas
            -->
            <rect width="@widthRectLegend" height="@heightRectLegend" x="5" y="5" fill="#32587a"></rect>
            <foreignObject x="5" y="5" width="@widthRectLegend" height="@heightRectLegend">
                <div class="BlockIndex">
                    <p style="color:#442f1c; margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">  zoom : Maj▲ + roulette</p>
                    <p style="color:rgb(140,140,140); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">  gris : bloqué</p>
                    <p style="color:rgb(228, 231, 245); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">  blanc: disponible</p>
                    <p style="color:rgb(199,160,53); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">  jaune: consulté</p>
                    <p style="color:rgb(88,150,105); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">  vert : completé</p>
                </div>
            </foreignObject>

            <rect width="@widthRectLegend" height="@heightRectStats" x="@(sizeSvgDictionary["width"] - widthRectLegend - 5)" y="5" fill="#32587a"></rect>
            <foreignObject x="@(sizeSvgDictionary["width"] - widthRectLegend - 5)" y="5" width="@widthRectLegend" height="@heightRectStats">
                <div class="BlockIndex">
                    <p style="color:rgb(228, 231, 245); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">@pourcentageCompleter % noeuds completés</p>
                    <p style="color:rgb(228, 231, 245); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">@noeudComplete / @(noeudAffiche.Count() - 1) noeuds completés</p>
                    <p style="color:rgb(228, 231, 245); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">noeuds recommandés :</p>
                    @foreach(GrapheView noeud in topNoeudRecommander)
                    {
                        int idTemporaire = noeud.Id;
                        <p @onclick="() => OnClick(topNoeudRecommander.Where(n => n.Id == idTemporaire).Select(n => n.Id).FirstOrDefault())" style="color:rgb(228, 231, 245); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;" @onmouseover="() => OnMouseOverNoeuds(idTemporaire)" @onmouseout="() => OnMouseOut()"> - <a href="/theorie/@idTemporaire" style="color:rgb(228, 231, 245); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">@noeud.Code</a></p>        
                    }
                    @if(topNoeudRecommander.Count == 0)
                    {
                        <p style="color:rgb(228, 231, 245); margin-left:10px; font-size:@(sizeSvgDictionary["width"] / 100)px;">aucun noeud recommandé</p>
                    }
                </div>
            </foreignObject>       
        </svg>
    </div>
}

@code {
    //methode pour le debugage : JSRuntim.InvokeVoidAsync("console.log",x);

    public int idGraphe{ get; set;}

    private const double forceZoom = 0.1;

    private double widthViewbox, heightViewbox, mouseX, mouseY, deplacementWidth, deplacementHeight, deplacementX, deplacementY, scaleZoom, translationX, translationY;
    private bool leftClicPress,watchRunning, initFinis,debug,shouldReRender;
    private int rayonCercleSvg,positionXRectHover,positionYRectHover,widthRectHover,heightRectHover,pointAXPolyHover,pointAYPolyHover,pointBXPolyHover,pointBYPolyHover,pointCXPolyHover,pointCYPolyHover,widthRectLegend,heightRectLegend, heightRectStats, noeudComplete, pourcentageCompleter,xBordureHover,yBordureHover;

    private HttpClient httpClient;
    private Client client;
    private IEnumerable<GrapheView> noeudAffiche;
    private IEnumerator<GrapheView> enumerator;
    private IEnumerable<HoverView> infoHover;

    private string displayHover,nomHover,descHover;
    private int? ptsHover;
    private string[] liaisonSecHover;
    private List<GrapheView> topNoeudRecommander;
    private HoverView noeudHover;
    private Coordonne coordonne;

    private Dictionary<string, int> viewboxDictionary = new Dictionary<string, int>();
    private Dictionary<string, int> sizeSvgDictionary = new Dictionary<string, int>(); 
    private Dictionary<string, int> startPointsDictionary = new Dictionary<string, int>(); 
    private Dictionary<string, int> startPointsAbsoluteDictionary = new Dictionary<string, int>(); 
    private Dictionary<string, int> endPointsDictionary = new Dictionary<string, int>();

    private Dictionary<int, Coordonne> noeudsCoordonneDictionnary = new Dictionary<int, Coordonne>();

    private GrapheView[][] structureGraphe = new GrapheView[1][];
    private GrapheView[][] structureGrapheTemporaire = new GrapheView[1][];

    private int[] noeudsParEtages = new int[1];
    private int[] noeudsParEtagesTemporaire = new int[1];

    private BoundingClientRect? element = null;

    //données des boucle d'affichages

    private int hauteurEtage, paddingTop, positionY, positionParentY, widthRepartition, widthParentRepartition, paddingLeft, marginLeft, paddingLeftParent, marginLeftParent, largeurNoeud, largeurNoeudParent, positionX, positionParentX, indexNoeudParent;
    private string couleurAffichageCercle,couleurAffichageTexte,couleurBloquer,couleurNonConsulter,couleurConsulter,couleurCompleter,couleurTexteBloquer,couleurTexteNonConsulter,couleurTexteConsulter,couleurTexteCompleter;

    private GrapheView[] noeudsTest;

    /// <summary>
    /// Initialise les variables du composant pour éviter les références nulles et appelle les fonctions de tris pour organiser les noeuds de la bonne façon
    /// </summary>
    /// Avant la boucle :
    ///     <param name="initFinis"> false tant que la fonction n'est pas fini. Utilisé dans l'affichage pour s'assurer que l'initialisation est terminé </param>
    ///     <param name="debug"> défini si le mode débug est actibé ou non. Créé des données de test s'il est actif </param>
    ///     <param name="viewboxDictionary"> Garde en mémoire les valeurs de la ViewBox utilisée dans la balise SVG </param>
    ///     <param name="sizeSvgDictionary"> Garde en mémoire la taille des balises SVG. Change à chaque changement de taille de la balise </param>
    ///     <param name="startPointsDictionary"> Voir commentaire OnMouseDown() </param>
    ///     <param name="startPointsAbsoluteDictionary"> Voir commentaire OnMouseDown() </param>
    ///     <param name="endPointsDictionary"> Voir commentaire OnMouseMove() </param>
    ///     <param name="scaleZoom"> Voir commentaire OnWheelMove() </param>
    ///     <param name="displayHover"> Voir commentaire OnMouseOver() </param>
    ///     <param name="liaisonSecHover"> Liste des liaisons secondaires des noeuds. S'affiche dans le rect over </param>
    ///     <param name="xBordureHover"> Coordonnée en X du cercle servant de bordure </param>
    ///     <param name="yBordureHover"> Coordonnée en Y du cercle servant de bordure </param>
    ///     <param name="shouldReRender"> Valeur précisant au visuel si il doit de nouveau render après un appel de fonction provenant d'un évènement Blazor VU QU'ON PEUT PAS LES FUCKING DESACTIVER, A CHAQUE CALL Y RERENDER CE QUI REND IMPOSSIBLE L'UTILISATION DE OnMouseMove, A CHAQUE FUCKING PIXEL TU RERENDER TOUT AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</param>
    ///     <param name="handler"> Créé le httpClient </param>
    ///     <param name="httpClient"> Créé la base du client </param>
    ///     <param name="client"> Communique avec l'API en utilisant NSwag </param>
    ///     <param name="noeudAffiche"> Résultat de la requête faite à GrapheView. Utilise l'ID du graphe pour récupérer les informations d'affichage des noeuds associés </param>
    ///     <param name="infoHover"> Résultat de la requête faite à HoverView. Utilise l'ID du graphe pour récupérer les informations d'affichage des paramètres d'hover des noeuds associés </param>
    ///     <param name="noeudComplete"> Nombre de noeuds complétés par l'étudiant </param>
    ///     <param name="pourcentageCompleter"> Pourcentage de noeuds complétés </param>
    ///     <param name="enumerator"> Sert à boucler dans une ICollection </param>
    ///     <param name="topNoeudRecommander"> Liste de 3 noeuds recommandés (voir UpdateGraph). Priorise les noeuds en bloque d'autres, ainsi que ceux proche de la racine </param>
    /// Dans la boucle :
    ///     <param name="structureGraphe"> Tableau 2D contenant tout les noeuds après le tri. Utilisé pour l'affichage </param>
    ///     <param name="structureGrapheTemporaire"> Tableau 2D temporaire utlisé pour adapter la taille de structureGraphe </param>
    ///     <param name="etage"> Garde en mémoire l'étage sur lequel le noeud vas se situer. Utilisé dans la boucle foreach </param>
    ///     <param name="noeudsParEtages"> Tableau gardant le nombre de noeuds par étages pour adapter la taille de structureGraphe </param>
    ///     <param name="noeudsParEtagesTemporaire"> Tableau temporaire utilisé pour adapter la taille de noeudsParEtage </param>
    protected async override void OnInitialized()
    {
        Console.WriteLine("graphe initialized");
        initFinis = false;
        debug = false;

        updateService.RefreshRequested += this.RefreshState;

        viewboxDictionary.Add("x", 0);
        viewboxDictionary.Add("y", 0);
        viewboxDictionary.Add("width", 0);
        viewboxDictionary.Add("height", 0);

        sizeSvgDictionary.Add("width", 0);
        sizeSvgDictionary.Add("height", 0);

        startPointsDictionary.Add("x", 0);
        startPointsDictionary.Add("y", 0);

        startPointsAbsoluteDictionary.Add("x", 0);
        startPointsAbsoluteDictionary.Add("y", 0);

        endPointsDictionary.Add("x", 0);
        endPointsDictionary.Add("y", 0);

        scaleZoom = 1;
        topNoeudRecommander = new List<GrapheView>();

        displayHover = "hidden";
        liaisonSecHover = new string[0];
        xBordureHover = 0;
        yBordureHover = 0;

        shouldReRender = true;

        var builder = WebApplication.CreateBuilder();

        var handler = new HttpClientHandler();
        handler.ClientCertificateOptions = ClientCertificateOption.Manual;
        handler.ServerCertificateCustomValidationCallback =
            (httpRequestMessage, cert, cetChain, policyErrors) =>
            {
                return true;
            };
        httpClient = new HttpClient(handler);
        httpClient.BaseAddress = new Uri(builder.Configuration["API:Use"]);

        client = new Client(httpClient);

        UpdateGraphe();
    }

    /// <summary>
    /// Met à jour les noeuds et autres valeurs logistique du graph avec les donénes stockées dans sessionStorage
    /// </summary>
    /// <param name="sessionStorage"> Service de stockage du projet. Fonctionne comme un dictionnaore (key-value) </param>
    private async void UpdateGraphe()
    {
        try
        {
            if(sessionStorage != null)
            {
                if(await sessionStorage.ContainKeyAsync("idGraphe") && await sessionStorage.GetItemAsync<int>("idGraphe") != 0)
                {
                    idGraphe = await sessionStorage.GetItemAsync<int>("idGraphe");

                    noeudAffiche = client.GrapheView2Async(idGraphe).Result;
                    infoHover = client.Hover2Async(idGraphe).Result;
                    noeudComplete = noeudAffiche.Where(n => n.CodeStatus == 4).Count();
                    pourcentageCompleter = (int)Math.Round((double)noeudComplete * 100 / (noeudAffiche.Count() - 1));

                    enumerator = noeudAffiche.GetEnumerator();

                    //données de test.
                    if(debug)
                    {
                        noeudsTest = new GrapheView[55];

                        for(int i = 0; i < noeudsTest.Length; i++)
                        {
                            noeudsTest[i] = new GrapheView(){Id = i,Code = "noeud" + i};
                        }

                        noeudsTest[0].LiaisonPrincipal = 0;

                        noeudsTest[1].LiaisonPrincipal = (int)noeudsTest[0].Id;
                        noeudsTest[2].LiaisonPrincipal = (int)noeudsTest[0].Id;

                        noeudsTest[3].LiaisonPrincipal = (int)noeudsTest[2].Id;
                        noeudsTest[4].LiaisonPrincipal = (int)noeudsTest[1].Id;
                        noeudsTest[5].LiaisonPrincipal = (int)noeudsTest[2].Id;

                        noeudsTest[6].LiaisonPrincipal = (int)noeudsTest[5].Id;
                        noeudsTest[7].LiaisonPrincipal = (int)noeudsTest[3].Id;
                        noeudsTest[8].LiaisonPrincipal = (int)noeudsTest[4].Id;
                        noeudsTest[9].LiaisonPrincipal = (int)noeudsTest[5].Id;

                        noeudsTest[10].LiaisonPrincipal = (int)noeudsTest[8].Id;
                        noeudsTest[11].LiaisonPrincipal = (int)noeudsTest[6].Id;
                        noeudsTest[12].LiaisonPrincipal = (int)noeudsTest[9].Id;
                        noeudsTest[13].LiaisonPrincipal = (int)noeudsTest[7].Id;
                        noeudsTest[14].LiaisonPrincipal = (int)noeudsTest[6].Id;

                        noeudsTest[15].LiaisonPrincipal = (int)noeudsTest[10].Id;
                        noeudsTest[16].LiaisonPrincipal = (int)noeudsTest[10].Id;
                        noeudsTest[17].LiaisonPrincipal = (int)noeudsTest[12].Id;
                        noeudsTest[18].LiaisonPrincipal = (int)noeudsTest[11].Id;
                        noeudsTest[19].LiaisonPrincipal = (int)noeudsTest[12].Id;
                        noeudsTest[20].LiaisonPrincipal = (int)noeudsTest[14].Id;

                        noeudsTest[21].LiaisonPrincipal = (int)noeudsTest[17].Id;
                        noeudsTest[22].LiaisonPrincipal = (int)noeudsTest[16].Id;
                        noeudsTest[23].LiaisonPrincipal = (int)noeudsTest[15].Id;
                        noeudsTest[24].LiaisonPrincipal = (int)noeudsTest[16].Id;
                        noeudsTest[25].LiaisonPrincipal = (int)noeudsTest[18].Id;
                        noeudsTest[26].LiaisonPrincipal = (int)noeudsTest[19].Id;
                        noeudsTest[27].LiaisonPrincipal = (int)noeudsTest[20].Id;

                        noeudsTest[28].LiaisonPrincipal = (int)noeudsTest[27].Id;
                        noeudsTest[29].LiaisonPrincipal = (int)noeudsTest[24].Id;
                        noeudsTest[30].LiaisonPrincipal = (int)noeudsTest[26].Id;
                        noeudsTest[31].LiaisonPrincipal = (int)noeudsTest[23].Id;
                        noeudsTest[32].LiaisonPrincipal = (int)noeudsTest[25].Id;
                        noeudsTest[33].LiaisonPrincipal = (int)noeudsTest[22].Id;
                        noeudsTest[34].LiaisonPrincipal = (int)noeudsTest[21].Id;
                        noeudsTest[35].LiaisonPrincipal = (int)noeudsTest[21].Id;

                        noeudsTest[36].LiaisonPrincipal = (int)noeudsTest[31].Id;
                        noeudsTest[37].LiaisonPrincipal = (int)noeudsTest[29].Id;
                        noeudsTest[38].LiaisonPrincipal = (int)noeudsTest[34].Id;
                        noeudsTest[39].LiaisonPrincipal = (int)noeudsTest[35].Id;
                        noeudsTest[40].LiaisonPrincipal = (int)noeudsTest[32].Id;
                        noeudsTest[41].LiaisonPrincipal = (int)noeudsTest[33].Id;
                        noeudsTest[42].LiaisonPrincipal = (int)noeudsTest[29].Id;
                        noeudsTest[43].LiaisonPrincipal = (int)noeudsTest[28].Id;
                        noeudsTest[44].LiaisonPrincipal = (int)noeudsTest[35].Id;

                        noeudsTest[45].LiaisonPrincipal = (int)noeudsTest[38].Id;
                        noeudsTest[46].LiaisonPrincipal = (int)noeudsTest[37].Id;
                        noeudsTest[47].LiaisonPrincipal = (int)noeudsTest[40].Id;
                        noeudsTest[48].LiaisonPrincipal = (int)noeudsTest[44].Id;
                        noeudsTest[49].LiaisonPrincipal = (int)noeudsTest[42].Id;
                        noeudsTest[50].LiaisonPrincipal = (int)noeudsTest[39].Id;
                        noeudsTest[51].LiaisonPrincipal = (int)noeudsTest[42].Id;
                        noeudsTest[52].LiaisonPrincipal = (int)noeudsTest[40].Id;
                        noeudsTest[53].LiaisonPrincipal = (int)noeudsTest[44].Id;
                        noeudsTest[54].LiaisonPrincipal = (int)noeudsTest[41].Id;
                    }

                    structureGraphe = new GrapheView[][] {};
                    structureGrapheTemporaire = new GrapheView[][] {};
                    noeudsParEtages = new int[] {};
                    noeudsParEtagesTemporaire = new int[] {};

                    while(enumerator.MoveNext())
                    {
                        int etage = 0;
                        GrapheView noeud = enumerator.Current;

                        etage = CalculEtage(noeud, etage);

                        if(etage >= noeudsParEtages.Length)
                        {
                            noeudsParEtagesTemporaire = new int[etage + 1];
                            for(int l = 0; l < noeudsParEtages.Length; l++)
                            {
                                noeudsParEtagesTemporaire[l] = noeudsParEtages[l];
                            }
                            noeudsParEtages = noeudsParEtagesTemporaire;
                        }
                        noeudsParEtages[etage]++;

                        structureGrapheTemporaire = new GrapheView[noeudsParEtages.Length][];

                        for(int e = 0; e < structureGrapheTemporaire.Length; e++)
                        {
                            structureGrapheTemporaire[e] = new GrapheView[noeudsParEtages[e]];
                        }

                        for(int j = 0; j < structureGraphe.Length;j++)
                        {
                            for(int k = 0; k < structureGraphe[j].Length;k++)
                            {
                                structureGrapheTemporaire[j][k] = structureGraphe[j][k];
                            }
                        }

                        structureGraphe = structureGrapheTemporaire;

                        structureGraphe[etage][noeudsParEtages[etage] - 1] = noeud;

                    }

                    structureGraphe = TrieTblNoeuds(structureGraphe);

                    topNoeudRecommander = new List<GrapheView>();

                    foreach(GrapheView noeud in noeudAffiche.Where(n => n.CodeStatus == 1).Where(n => n.Disponibilite < DateTimeOffset.Now))
                    {
                        foreach(HoverView hover in infoHover.Where(h => h.Id == noeud.Id).Where(h => noeudAffiche.Where(n => n.CodeStatus != 1).Where(n => n.CodeStatus != 4).Any(n => n.Code == h.CodeParent)))
                        {
                            if(hover.CodeParent != null)
                            {
                                if(!topNoeudRecommander.Any(t => t.Code == hover.CodeParent))
                                {
                                    topNoeudRecommander.Add(new GrapheView(){Id = noeudAffiche.Where(n => n.Code == hover.CodeParent).Where(n => n.GrapheId == hover.GrapheId).Select(n => n.Id).FirstOrDefault(), Code = hover.CodeParent});        
                                }

                            }

                        }

                    }

                    if(topNoeudRecommander.Count > 3)
                    {
                        topNoeudRecommander = topNoeudRecommander.Take(3).ToList();
                    }
                    else if(topNoeudRecommander.Count < 3)
                    {
                        for(int j = 0; j < structureGraphe.GetLength(0); j++)
                        {
                            if(topNoeudRecommander.Count < 3)
                            {
                                for (int k = 0; k < structureGraphe[j].Length; k++)
                                {
                                    if(topNoeudRecommander.Count < 3 && structureGraphe[j][k].CodeStatus != 1 && structureGraphe[j][k].CodeStatus != 4)
                                    {
                                        if(!topNoeudRecommander.Any(t => t.Id == structureGraphe[j][k].Id))
                                        {
                                            topNoeudRecommander.Add(structureGraphe[j][k]);    
                                        }
                                    }
                                }
                            }
                        }
                    }

                    initFinis = true;

                    Console.WriteLine("param finis statehaschanged");
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
        catch(JSDisconnectedException e)
        {
            //ignore voir https://stackoverflow.com/questions/72488563/blazor-server-side-application-throwing-system-invalidoperationexception-javas
        }

    }

    /// <summary>
    /// Récupère la taille de la balise SVG pour adapter les valeurs visuelles à la taille de la page
    /// </summary>
    /// <param name="firstRender"></param>
    /// <param name="element"> Objet gardant en mémoire la taille de la balise SVG </param>
    /// <param name="viewboxDictionary"> Voir commentaire OnInitialized </param>
    /// <param name="sizeSvgDictionary"> Voir commentaire OnInitialized </param>
    /// <param name="rayonCercleSvg"> Taille du rayon des cercles utilisés pour afficher le noeud dans le graphe </param>
    /// <param name="widthRectLegend"> Largeur du rectangle contenant la légende du graphe </param>
    /// <param name="heightRectLegend"> Hauteur du rectangle contenant la légende du graphe </param>
    /// <param name="heightRectStats"> Hauteur du rectangle contenant les statistiqurd du graphe </param>
    protected override async void OnAfterRender(bool firstRender)
    {
        if(initFinis)
        {
            try
            {
                element = await JSRuntim.InvokeAsync<BoundingClientRect>("GetSizeElement", "svgGraphiqueComponent");
            }
            catch(Exception e)
            {
                await InvokeAsync(StateHasChanged);
            }

            if(Math.Round(element.Width) > sizeSvgDictionary["width"] + 20 || Math.Round(element.Width) < sizeSvgDictionary["width"] - 20 || Math.Round(element.Height) > sizeSvgDictionary["height"] + 20 || Math.Round(element.Height) < sizeSvgDictionary["height"] - 20)
            {
                //JSRuntim.InvokeVoidAsync("console.log","changement de taille du svg");
                sizeSvgDictionary["width"] = (int)Math.Round(element.Width);
                sizeSvgDictionary["height"] = (int)Math.Round(element.Height);

                viewboxDictionary["width"] = sizeSvgDictionary["width"];
                viewboxDictionary["height"] = sizeSvgDictionary["height"];
                viewboxDictionary["x"] = 0;
                viewboxDictionary["y"] = 0;

                if(element.Width <= element.Height)
                {
                    rayonCercleSvg = (int)Math.Round(element.Width * 4 / 100);    
                }
                else
                {
                    rayonCercleSvg = (int)Math.Round(element.Height * 4 / 100);
                }

                widthRectLegend = (int)Math.Round((double)(15 * viewboxDictionary["width"]) / 100);
                heightRectLegend = (int)Math.Round((double)(28 * viewboxDictionary["height"]) / 100);

                heightRectStats =  (int)Math.Round((double)(30 * viewboxDictionary["height"]) / 100);

                noeudsCoordonneDictionnary.Clear();

                await InvokeAsync(StateHasChanged);
            }
        }

    }
                  
    /// <summary>
    /// Zoom dans le graphe
    /// </summary>
    /// <details>
    /// Le 1er if vérifie si l'utilisateur appuie sur la touche Maj▲ pour éviter les conflits avec le scroll normal
    /// Le 2ème if vérifie si l'utilisateur ne dépasse pas la limite de dézoom qui est 2 fois la taille de l'élément
    /// </details>
    /// <param name="mouse"></param>
    /// <param name="widthViewbox"> Largeur de la viewbox actuelle </param>
    /// <param name="heightViewbox"> Hauteur de la viewbox actuelle </param>
    /// <param name="mouseX"> Position de la souris sur l'axe horizontal par rapport à l'élément dans laquelle elle se situe </param>
    /// <param name="mouseY"> Position de la souris sur l'axe vertical par rapport à l'élément dans laquelle elle se situe </param>
    /// <param name="deplacementWidth"> Modification de la largeur de la viewbox (pixel) </param>
    /// <param name="deplacementHeight"> Modification de la hauteur de la viewbox (pixel) </param>
    /// <param name="deplacementX"> Déplacement en X de la viewbox (pixel) /!\ placement inversé </param>
    /// <param name="deplacementY"> Déplacement en Y de la viewbox (pixel) /!\ placement inversé </param>
    /// <param name="scaleZoom"> Intensité du zoom actuel </param>
    public void OnWheelMove(WheelEventArgs mouse)
    {
        if(mouse.ShiftKey)
        {
            widthViewbox = viewboxDictionary["width"];
            heightViewbox = viewboxDictionary["height"];
            mouseX = mouse.OffsetX;
            mouseY = mouse.OffsetY;


            deplacementWidth = widthViewbox * Math.Sign(mouse.DeltaY) * forceZoom;
            deplacementHeight = heightViewbox * Math.Sign(mouse.DeltaY) * forceZoom;

            deplacementX = deplacementWidth * mouseX / sizeSvgDictionary["width"];
            deplacementY = deplacementHeight * mouseY / sizeSvgDictionary["height"];

            viewboxDictionary["x"] -= (int)Math.Round(deplacementX);
            viewboxDictionary["y"] -= (int)Math.Round(deplacementY);
            viewboxDictionary["width"] += (int)Math.Round(deplacementWidth);
            viewboxDictionary["height"] += (int)Math.Round(deplacementHeight);

            if(viewboxDictionary["width"] > (sizeSvgDictionary["width"] * 2) && deplacementWidth > 0)
            {
                viewboxDictionary["width"] = sizeSvgDictionary["width"] * 2;
                viewboxDictionary["height"] = sizeSvgDictionary["height"] * 2;
                viewboxDictionary["x"] += (int)Math.Round(deplacementX);
                viewboxDictionary["y"] += (int)Math.Round(deplacementY);
            }

            scaleZoom = (double)sizeSvgDictionary["width"] / (double)viewboxDictionary["width"];
            //JSRuntim.InvokeVoidAsync("console.log",scaleZoom);
        }

    }

    /// <summary>
    /// Définie les variavles des dictionnaires startPointsDictionary et startPointsAbsoluteDictionary avec les valeures de positions de la souris pour qu'ils soient utilisés dans les calculs lors du placement de la souris
    /// </summary>
    /// <param name="mouse"></param>
    /// <param name="leftClicPress"> Vérifie si le clic gauche est cliqué dans la fonction OnMouseUp </param>
    /// <param name="startPointsDictionnary"> Point de départ lors du calcul de déplacement de la souris </param>
    /// <param name="startPointsAbsoluteDictionary"> Garde en mémoire le point de départ inital car startPoints est modifié. Utilisé dans la fonction OnClick </param>
    public void OnMouseDown(MouseEventArgs mouse)
    {
        if(mouse.Buttons == 1)
        {
            startPointsDictionary["x"] = (int)Math.Round(mouse.OffsetX);
            startPointsDictionary["y"] = (int)Math.Round(mouse.OffsetY);

            startPointsAbsoluteDictionary["x"] = (int)Math.Round(mouse.OffsetX);
            startPointsAbsoluteDictionary["y"] = (int)Math.Round(mouse.OffsetY);

            leftClicPress = true;
        }
    }

    /// <summary>
    /// Calcule la distance parcouru de la souris et modifie la viewbox en conséquence
    /// </summary>
    /// <details>
    /// On additonne à la viewbox plutôt que soustraire car on veut effectuer le déplacement dans la direction inverse
    /// On ajuste les valeurs de startPointsDictionary pour qu'elles correspondent à la position finale
    /// Le 2ème if vérifie si l'on dépasse la taille de l'élément SVG. Si oui, on annule les modifications
    /// </details>
    /// <param name="mouse"></param>
    /// <param name="endPointsDictionary"> Position de la sours lors de l'appel fonction. Après le mouvement </param>
    /// <param name="translationX"> Déplacement en X entre startPointsDictionary et endPointsDictionary. Modifié selon le zoom </param>
    /// <param name="translationY"> Déplacement en Y entre startPointsDictionary et endPointsDictionart. Modifié selon le zoom </param>
    public void OnMouseMove(MouseEventArgs mouse)
    {
        if(mouse.Buttons == 1)
        {
            endPointsDictionary["x"] = (int)Math.Round(mouse.OffsetX);
            endPointsDictionary["y"] = (int)Math.Round(mouse.OffsetY);

            translationX = (startPointsDictionary["x"] - endPointsDictionary["x"]) / scaleZoom;
            translationY = (startPointsDictionary["y"] - endPointsDictionary["y"]) / scaleZoom;


            viewboxDictionary["x"] += (int)Math.Round(translationX);
            viewboxDictionary["y"] += (int)Math.Round(translationY);


            startPointsDictionary["x"] -= (int)Math.Round(translationX);
            startPointsDictionary["y"] -= (int)Math.Round(translationY);

            if(viewboxDictionary["x"] > sizeSvgDictionary["width"] || viewboxDictionary["x"] < sizeSvgDictionary["width"] * -1 || viewboxDictionary["y"] > sizeSvgDictionary["height"] || viewboxDictionary["y"] < sizeSvgDictionary["height"] * -1)
            {
                viewboxDictionary["x"] -= (int)Math.Round(translationX);
                viewboxDictionary["y"] -= (int)Math.Round(translationY);

                startPointsDictionary["x"] += (int)Math.Round(translationX);
                startPointsDictionary["y"] += (int)Math.Round(translationY);
            }

        }
        else
        {
            shouldReRender = false;
        }

    }

    /// <summary>
    /// Même chose que la fonction OnMouseMove. Change la valeur de leftClicPress
    /// </summary>
    /// <details>
    /// Voir la possibilité de suppression de la fonction
    /// </details>
    /// <param name="mouse"></param>
    public void OnMouseUp(MouseEventArgs mouse)
    {
        if(leftClicPress)
        {
            endPointsDictionary["x"] = (int)Math.Round(mouse.OffsetX);
            endPointsDictionary["y"] = (int)Math.Round(mouse.OffsetY);

            translationX = (startPointsDictionary["x"] - endPointsDictionary["x"]) / scaleZoom;
            translationY = (startPointsDictionary["y"] - endPointsDictionary["y"]) / scaleZoom;

            viewboxDictionary["x"] += (int)Math.Round(translationX);
            viewboxDictionary["y"] += (int)Math.Round(translationY);
        }
        leftClicPress = false;
    }

    /// <summary>
    /// Calcule la distace entre l'étage du noeud et l'étage d'origine du noeud
    /// </summary>
    /// <param name="noeud"></param>
    /// <param name="etage"></param>
    /// <returns></returns>
    private int CalculEtage(GrapheView noeud, int etage)
    {
        if(noeud.LiaisonPrincipal == 0)
        {
            return etage;
        }
        else
        {
            return CalculEtage(noeudAffiche.Where(n => n.Id == noeud.LiaisonPrincipal).FirstOrDefault(), etage + 1);
        }
    }

    /// <summary>
    /// Trie chaque ligne du tableau pour que les enfants soient dans le même ordre que leurs parents
    /// </summary>
    /// <param name="tableau"></param>
    /// <param name="tblTemporaire"> Contient les index des parents des noeuds de chaque ligne. Trié en même temps que la variable tableau </param>
    /// <returns></returns>
    private GrapheView[][] TrieTblNoeuds(GrapheView[][] tableau)
    {
        int[] tblTemporaire;

        for(int j = 0; j < tableau.Length; j++)
        {
            if(j != 0)
            {
                tblTemporaire = new int[tableau[j].Length];

                for(int i = 0; i < tableau[j].Length; i++)
                {
                    tblTemporaire[i] = Array.IndexOf(tableau[j - 1], Array.Find(tableau[j -1],noeud => noeud.Id == tableau[j][i].LiaisonPrincipal));
                }

                Array.Sort(tblTemporaire, tableau[j]);
            }
        }

        return tableau;
    }

    /// <summary>
    /// Définit la taille et la position du rectangle hover, le contenu à afficher et définit la visibilité à "visible"
    /// </summary>
    /// <details>
    /// Les if vérifient que le rectangle ne dépassent pas la balise SVG. Si oui, il inverse les valeurs d'affichage
    /// </details>
    /// <param name="x"> Coordonnée en X du noeud sous la souris </param>
    /// <param name="y"> Coordonnée en Y du noeud sous la souris </param>
    /// <param name="id"> ID du noeud sous la souris </param>
    /// <param name="widthRectHover"> Largeur du rectancle hover. Varie selon le zoom et la taille de la page </param>
    /// <param name="heightRectHover"> Hauteur du rectangle hover. Varie salon le zoom et la taille de la page </param>
    /// <param name="positionXRectHover"> Position sur l'axe X du coin sup. gauche du rectangle hover </param>
    /// <param name="pointAXPolyHover"> Position sur l'axe X du point A constituant le triangle entre le noeud et le rectangle hover </param>
    /// <param name="pointBXPolyHover"> Position sur l'axe X du point B constituant le triangle entre le noeud et le rectangle hover </param>
    /// <param name="pointCXPolyHover"> Position sur l'axe X du point C constituant le triangle entre le noeud et le rectangle hover </param>
    /// <param name="positionYRectHover"> Position sur l'axe Y du coin sup. gauche du rectangle hover </param>
    /// <param name="pointAYPolyHover"> Position sur l'axe Y du point A constituant le triangle entre le noeud et le rectangle hover </param>
    /// <param name="pointBYPolyHover"> Position sur l'axe Y du point B constituant le triangle entre le noeud et le rectangle hover </param>
    /// <param name="pointCYPolyHover"> Position sur l'axe Y du point C constituant le triangle entre le noeud et le rectangle hover </param>
    /// <param name="noeudHover"> Ensemble des informations à afficher. Trouvées en utilisant l'ID du noeud sur lequel passe la souris </param>
    /// <param name="nomHover"> Code du noeud à afficher dans le rectangle hover </param>
    /// <param name="descHover"> Description du noeud à afficher dans le rectangle hover </param>
    /// <param name="ptsHover"> Somme des points de toutes les pages associées au noeud à afficher dans le rectangle hover </param>
    /// <param name="liaisonSecHover"> Tableau constitué de toutes les laisons secondaire du noeud. 1ère entrée à "aucune" si pas de liaison secondaire </param>
    /// <param name="displayHover"> Bool déterminant si le rectangle hover doit être affiché </param>
    private void OnMouseOverNoeuds(int id)
    {

        widthRectHover = (int)Math.Round((double)(15 * viewboxDictionary["width"]) / 100);
        heightRectHover = (int)Math.Round((double)(15 * viewboxDictionary["height"]) / 100);


        if(noeudsCoordonneDictionnary[id].x + (widthRectHover + rayonCercleSvg) > element.Width)
        {
            positionXRectHover = noeudsCoordonneDictionnary[id].x - widthRectHover - rayonCercleSvg;
            pointAXPolyHover = noeudsCoordonneDictionnary[id].x - (int)Math.Round((Math.Cos(45) * rayonCercleSvg));
            pointBXPolyHover = noeudsCoordonneDictionnary[id].x - (int)Math.Round(rayonCercleSvg + (rayonCercleSvg - Math.Cos(45) * rayonCercleSvg));
            pointCXPolyHover = noeudsCoordonneDictionnary[id].x - rayonCercleSvg;
        }
        else
        {
            positionXRectHover = noeudsCoordonneDictionnary[id].x + rayonCercleSvg;
            pointAXPolyHover = noeudsCoordonneDictionnary[id].x + (int)Math.Round((Math.Cos(45) * rayonCercleSvg));
            pointBXPolyHover = noeudsCoordonneDictionnary[id].x + (int)Math.Round(rayonCercleSvg + (rayonCercleSvg - Math.Cos(45) * rayonCercleSvg));
            pointCXPolyHover = noeudsCoordonneDictionnary[id].x + rayonCercleSvg;
        }

        if(noeudsCoordonneDictionnary[id].y - (heightRectHover + rayonCercleSvg) < 0)
        {
            positionYRectHover = noeudsCoordonneDictionnary[id].y + rayonCercleSvg;
            pointAYPolyHover = noeudsCoordonneDictionnary[id].y + (int)Math.Round(Math.Sin(45) * rayonCercleSvg);
            pointBYPolyHover = noeudsCoordonneDictionnary[id].y + rayonCercleSvg;
            pointCYPolyHover = noeudsCoordonneDictionnary[id].y + (int)Math.Round(rayonCercleSvg + (rayonCercleSvg - (Math.Sin(45) * rayonCercleSvg)));
        }
        else
        {
            positionYRectHover = noeudsCoordonneDictionnary[id].y - heightRectHover - rayonCercleSvg;
            pointAYPolyHover = noeudsCoordonneDictionnary[id].y - (int)Math.Round(Math.Sin(45) * rayonCercleSvg);
            pointBYPolyHover = noeudsCoordonneDictionnary[id].y - rayonCercleSvg;
            pointCYPolyHover = noeudsCoordonneDictionnary[id].y - (int)Math.Round(rayonCercleSvg + (rayonCercleSvg - (Math.Sin(45) * rayonCercleSvg)));
        }

        noeudHover = infoHover.Where(g => g.Id == id).FirstOrDefault();
        nomHover = noeudHover.Code;
        descHover = noeudHover.Description;
        ptsHover = noeudHover.PtsTotal;

        liaisonSecHover = infoHover.Where(g => g.Id == id).Select(g => g.CodeParent).ToArray();


        if(liaisonSecHover[0] == null)
        {
            //liaisonSecHover = new string[1];
            liaisonSecHover[0] = "aucune";
        }

        xBordureHover = noeudsCoordonneDictionnary[id].x;
        yBordureHover = noeudsCoordonneDictionnary[id].y;

        displayHover = "visible";
    }

    /// <summary>
    /// Change la visibilité à hidden
    /// </summary>
    /// <param name="displayHover"> Voir commentaire OnMouseOverNoeud </param>
    private void OnMouseOut()
    {
        displayHover = "hidden";
    }

    /// <summary>
    /// Vérfie si l'utilisateur n'a pas déplacé sa souris. Change le status du noeud cliqué si son status égale 2, puis l'envoit vers la page de théorie correspondant à l'ID cliqué
    /// </summary>
    /// <param name="id"></param>
    /// <param name="startPointsAbsoluteDictionary"> Voir commentaire OnMouseDown </param>
    /// <param name="endPointsDictionary"> Voir commentaire OnMouseMove </param>
    /// <param name="noeudCliquer"> Permet de vérifier les informations du noeud cliqué </param>
    /// <param name="updateNoeud"> Créé à partie de noeudCliquer. Utilisé lors de la requete pour modifier la BD</param>
    private async void OnClick(int? id)
    {
        if((endPointsDictionary["x"] < startPointsAbsoluteDictionary["x"] + 15) && (endPointsDictionary["x"] > startPointsAbsoluteDictionary["x"] - 15) && (endPointsDictionary["y"] < startPointsAbsoluteDictionary["y"] + 15) && (endPointsDictionary["y"] > startPointsAbsoluteDictionary["y"] - 15))
        {
            GrapheView noeudCliquer = noeudAffiche.Where(n => n.Id == id).FirstOrDefault();

            if(noeudCliquer.LiaisonPrincipal != 0 && noeudCliquer.CodeStatus != 1)
            {
                if(noeudCliquer.CodeStatus == 2)
                {
                    Noeud updateNoeud = new Noeud()
                    {
                        Id = noeudCliquer.Id,
                        Status = 3,
                        Code = noeudCliquer.Code

                    };
                    client.ReadResponseAsString = true;
                    await client.NoeudsPUTAsync(noeudCliquer.Id, updateNoeud);
                }
                NavigationManager.NavigateTo("/theorie/" + id);
            }
        }
    }

    /// <summary>
    /// Réinitalise les valeurs de la viexbox à zéro
    /// </summary>
    /// <param name="viewboxDictionary"> Voir commentaire OnInitialized </param>
    /// <param name="scaleZoom"> Voir commentaire OnInitialized </param>
    private void ResetViewbox()
    {
        viewboxDictionary["x"] = 0;
        viewboxDictionary["y"] = 0;
        viewboxDictionary["width"] = sizeSvgDictionary["width"];
        viewboxDictionary["height"] = sizeSvgDictionary["height"];
        scaleZoom = 1;
    }

    /// <summary>
    /// Augmente le zoom du graphe sans utiliser la molette
    /// </summary>
    private async void AugmenterZoom()
    {
        viewboxDictionary["x"] += (int)Math.Round((viewboxDictionary["width"] * 0.1) * (sizeSvgDictionary["width"] / 2) / sizeSvgDictionary["width"]);
        viewboxDictionary["y"] += (int)Math.Round((viewboxDictionary["height"] * 0.1) * (sizeSvgDictionary["height"] / 2) / sizeSvgDictionary["height"]);
        viewboxDictionary["width"] -= (int)Math.Round(viewboxDictionary["width"] * 0.1);
        viewboxDictionary["height"] -= (int)Math.Round(viewboxDictionary["height"] * 0.1);

        scaleZoom = (double)sizeSvgDictionary["width"] / (double)viewboxDictionary["width"];

        await InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Réduit le zoom du graphe sans utiliser la molette
    /// </summary>
    private async void ReduireZoom()
    {
        if(viewboxDictionary["width"] < (sizeSvgDictionary["width"] * 2))
        {
            viewboxDictionary["x"] -= (int)Math.Round((viewboxDictionary["width"] * 0.1) * (sizeSvgDictionary["width"] / 2) / sizeSvgDictionary["width"]);
            viewboxDictionary["y"] -= (int)Math.Round((viewboxDictionary["height"] * 0.1) * (sizeSvgDictionary["height"] / 2) / sizeSvgDictionary["height"]);
            viewboxDictionary["width"] += (int)Math.Round(viewboxDictionary["width"] * 0.1);
            viewboxDictionary["height"] += (int)Math.Round(viewboxDictionary["height"] * 0.1);

        }
        if(viewboxDictionary["width"] > (sizeSvgDictionary["width"] * 2))
        {
            viewboxDictionary["width"] = sizeSvgDictionary["width"] * 2;
            viewboxDictionary["height"] = sizeSvgDictionary["height"] * 2;
        }
        scaleZoom = (double)sizeSvgDictionary["width"] / (double)viewboxDictionary["width"];

        await InvokeAsync(StateHasChanged);

    }

    /// <summary>
    /// Redirige vers l'aide
    /// </summary>
    private void MoveToAide()
    {
        NavigationManager.NavigateTo("/graphe/aide");
    }

    /// <summary>
    /// Appelée lors d'un changement d'état
    /// </summary>
    /// <returns> true si l'affichage doit se recharger </returns>
    protected override bool ShouldRender()
    {
        if(shouldReRender)
        {
            return true;
        }
        else
        {
            shouldReRender = true;
            return false;
        }
    }

    public async void RefreshState()
    {
        UpdateGraphe();
    }

    /// <summary>
    /// Stocke les coordonnées X et Y d'affichage des noeuds dans un objet
    /// </summary>
    private class Coordonne
    {
        public int x{ get; set; }
        public int y{ get; set; }
    }

    /// <summary>
    /// Enregistre les valeurs de taille d'un élément dans un objet
    /// </summary>
    public class BoundingClientRect
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double Top { get; set; }
        public double Right { get; set; }
        public double Bottom { get; set; }
        public double Left { get; set; }
    }

}
